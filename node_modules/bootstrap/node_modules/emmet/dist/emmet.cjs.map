{"version":3,"file":"emmet.cjs","sources":["../packages/scanner/scanner.js","../packages/abbreviation/dist/index.js","../packages/css-abbreviation/dist/index.js","../src/markup/attributes.ts","../src/markup/utils.ts","../src/markup/snippets.ts","../src/output-stream.ts","../src/markup/implicit-tag.ts","../src/markup/lorem/latin.json","../src/markup/lorem/russian.json","../src/markup/lorem/spanish.json","../src/markup/lorem/index.ts","../src/markup/addon/xsl.ts","../src/markup/addon/bem.ts","../src/markup/addon/label.ts","../src/markup/format/walk.ts","../src/markup/format/utils.ts","../src/markup/format/template.ts","../src/markup/format/comment.ts","../src/markup/format/html.ts","../src/markup/format/indent-format.ts","../src/markup/format/haml.ts","../src/markup/format/slim.ts","../src/markup/format/pug.ts","../src/markup/index.ts","../src/stylesheet/snippets.ts","../src/stylesheet/score.ts","../src/stylesheet/color.ts","../src/stylesheet/format.ts","../src/stylesheet/index.ts","../src/snippets/html.json","../src/snippets/css.json","../src/snippets/xsl.json","../src/snippets/pug.json","../src/snippets/variables.json","../src/config.ts","../src/extract-abbreviation/reader.ts","../src/extract-abbreviation/quotes.ts","../src/extract-abbreviation/brackets.ts","../src/extract-abbreviation/is-html.ts","../src/extract-abbreviation/index.ts","../src/index.ts"],"sourcesContent":["const defaultQuotedOptions = {\n    escape: 92, // \\ character\n    throws: false\n};\n/**\n * Check if given code is a number\n */\nfunction isNumber(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n */\nfunction isAlphaNumeric(code) {\n    return isNumber(code) || isAlpha(code);\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha(code);\n}\n/**\n * Check for Umlauts i.e. ä, Ä, ö, Ö, ü and Ü\n */\nfunction isUmlaut(code) {\n    return code === 196\n        || code == 214\n        || code === 220\n        || code === 228\n        || code === 246\n        || code === 252;\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @return `true` if quoted string was consumed. The contents of quoted string\n * will be available as `stream.current()`\n */\nfunction eatQuoted(stream, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    const quote = stream.peek();\n    if (stream.eat(isQuote)) {\n        while (!stream.eof()) {\n            switch (stream.next()) {\n                case quote:\n                    stream.start = start;\n                    return true;\n                case options.escape:\n                    stream.next();\n                    break;\n            }\n        }\n        // If we’re here then stream wasn’t properly consumed.\n        // Revert stream and decide what to do\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error('Unable to consume quoted string');\n        }\n    }\n    return false;\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param open Character code of pair opening\n * @param close Character code of pair closing\n * @return Returns `true` if character pair was successfully consumed, it’s\n * content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    if (stream.eat(open)) {\n        let stack = 1;\n        let ch;\n        while (!stream.eof()) {\n            if (eatQuoted(stream, options)) {\n                continue;\n            }\n            ch = stream.next();\n            if (ch === open) {\n                stack++;\n            }\n            else if (ch === close) {\n                stack--;\n                if (!stack) {\n                    stream.start = start;\n                    return true;\n                }\n            }\n            else if (ch === options.escape) {\n                stream.next();\n            }\n        }\n        // If we’re here then paired character can’t be consumed\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n        }\n    }\n    return false;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nexport { ScannerError, Scanner as default, eatPair, eatQuoted, isAlpha, isAlphaNumeric, isAlphaNumericWord, isAlphaWord, isNumber, isQuote, isSpace, isUmlaut, isWhiteSpace };\n//# sourceMappingURL=scanner.js.map\n","import Scanner, { isNumber, isQuote as isQuote$1, isSpace, isAlpha, isAlphaNumericWord, isUmlaut, ScannerError } from '@emmetio/scanner';\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction next(scanner) {\n    return scanner.tokens[scanner.pos++];\n}\nfunction slice(scanner, from = scanner.start, to = scanner.pos) {\n    return scanner.tokens.slice(from, to);\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    const token = peek(scanner);\n    if (token && test(token)) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction abbreviation(abbr, options = {}) {\n    const scanner = tokenScanner(abbr);\n    const result = statements(scanner, options);\n    if (readable(scanner)) {\n        throw error(scanner, 'Unexpected character');\n    }\n    return result;\n}\nfunction statements(scanner, options) {\n    const result = {\n        type: 'TokenGroup',\n        elements: []\n    };\n    let ctx = result;\n    let node;\n    const stack = [];\n    while (readable(scanner)) {\n        if (node = element(scanner, options) || group(scanner, options)) {\n            ctx.elements.push(node);\n            if (consume(scanner, isChildOperator)) {\n                stack.push(ctx);\n                ctx = node;\n            }\n            else if (consume(scanner, isSiblingOperator)) {\n                continue;\n            }\n            else if (consume(scanner, isClimbOperator)) {\n                do {\n                    if (stack.length) {\n                        ctx = stack.pop();\n                    }\n                } while (consume(scanner, isClimbOperator));\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n/**\n * Consumes group from given scanner\n */\nfunction group(scanner, options) {\n    if (consume(scanner, isGroupStart)) {\n        const result = statements(scanner, options);\n        const token = next(scanner);\n        if (isBracket(token, 'group', false)) {\n            result.repeat = repeater$1(scanner);\n        }\n        return result;\n    }\n}\n/**\n * Consumes single element from given scanner\n */\nfunction element(scanner, options) {\n    let attr;\n    const elem = {\n        type: 'TokenElement',\n        name: void 0,\n        attributes: void 0,\n        value: void 0,\n        repeat: void 0,\n        selfClose: false,\n        elements: []\n    };\n    if (elementName(scanner, options)) {\n        elem.name = slice(scanner);\n    }\n    while (readable(scanner)) {\n        scanner.start = scanner.pos;\n        if (!elem.repeat && !isEmpty(elem) && consume(scanner, isRepeater)) {\n            elem.repeat = scanner.tokens[scanner.pos - 1];\n        }\n        else if (!elem.value && text(scanner)) {\n            elem.value = getText(scanner);\n        }\n        else if (attr = shortAttribute(scanner, 'id', options) || shortAttribute(scanner, 'class', options) || attributeSet(scanner)) {\n            if (!elem.attributes) {\n                elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];\n            }\n            else {\n                elem.attributes = elem.attributes.concat(attr);\n            }\n        }\n        else {\n            if (!isEmpty(elem) && consume(scanner, isCloseOperator)) {\n                elem.selfClose = true;\n                if (!elem.repeat && consume(scanner, isRepeater)) {\n                    elem.repeat = scanner.tokens[scanner.pos - 1];\n                }\n            }\n            break;\n        }\n    }\n    return !isEmpty(elem) ? elem : void 0;\n}\n/**\n * Consumes attribute set from given scanner\n */\nfunction attributeSet(scanner) {\n    if (consume(scanner, isAttributeSetStart)) {\n        const attributes = [];\n        let attr;\n        while (readable(scanner)) {\n            if (attr = attribute(scanner)) {\n                attributes.push(attr);\n            }\n            else if (consume(scanner, isAttributeSetEnd)) {\n                break;\n            }\n            else if (!consume(scanner, isWhiteSpace)) {\n                throw error(scanner, `Unexpected \"${peek(scanner).type}\" token`);\n            }\n        }\n        return attributes;\n    }\n}\n/**\n * Consumes attribute shorthand (class or id) from given scanner\n */\nfunction shortAttribute(scanner, type, options) {\n    if (isOperator(peek(scanner), type)) {\n        scanner.pos++;\n        // Consume multiple operators\n        let count = 1;\n        while (isOperator(peek(scanner), type)) {\n            scanner.pos++;\n            count++;\n        }\n        const attr = {\n            name: [createLiteral(type)]\n        };\n        if (count > 1) {\n            attr.multiple = true;\n        }\n        // Consume expression after shorthand start for React-like components\n        if (options.jsx && text(scanner)) {\n            attr.value = getText(scanner);\n            attr.expression = true;\n        }\n        else {\n            attr.value = literal$1(scanner) ? slice(scanner) : void 0;\n        }\n        return attr;\n    }\n}\n/**\n * Consumes single attribute from given scanner\n */\nfunction attribute(scanner) {\n    if (quoted(scanner)) {\n        // Consumed quoted value: it’s a value for default attribute\n        return {\n            value: slice(scanner)\n        };\n    }\n    if (literal$1(scanner, true)) {\n        const name = slice(scanner);\n        let value;\n        if (consume(scanner, isEquals)) {\n            if (quoted(scanner) || literal$1(scanner, true)) {\n                value = slice(scanner);\n            }\n        }\n        return { name, value };\n    }\n}\nfunction repeater$1(scanner) {\n    return isRepeater(peek(scanner))\n        ? scanner.tokens[scanner.pos++]\n        : void 0;\n}\n/**\n * Consumes quoted value from given scanner, if possible\n */\nfunction quoted(scanner) {\n    const start = scanner.pos;\n    const quote = peek(scanner);\n    if (isQuote(quote)) {\n        scanner.pos++;\n        while (readable(scanner)) {\n            if (isQuote(next(scanner), quote.single)) {\n                scanner.start = start;\n                return true;\n            }\n        }\n        throw error(scanner, 'Unclosed quote', quote);\n    }\n    return false;\n}\n/**\n * Consumes literal (unquoted value) from given scanner\n */\nfunction literal$1(scanner, allowBrackets) {\n    const start = scanner.pos;\n    const brackets = {\n        attribute: 0,\n        expression: 0,\n        group: 0\n    };\n    while (readable(scanner)) {\n        const token = peek(scanner);\n        if (brackets.expression) {\n            // If we’re inside expression, we should consume all content in it\n            if (isBracket(token, 'expression')) {\n                brackets[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else if (isQuote(token) || isOperator(token) || isWhiteSpace(token) || isRepeater(token)) {\n            break;\n        }\n        else if (isBracket(token)) {\n            if (!allowBrackets) {\n                break;\n            }\n            if (token.open) {\n                brackets[token.context]++;\n            }\n            else if (!brackets[token.context]) {\n                // Stop if found unmatched closing brace: it must be handled\n                // by parent consumer\n                break;\n            }\n            else {\n                brackets[token.context]--;\n            }\n        }\n        scanner.pos++;\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes element name from given scanner\n */\nfunction elementName(scanner, options) {\n    const start = scanner.pos;\n    if (options.jsx && consume(scanner, isCapitalizedLiteral)) {\n        // Check for edge case: consume immediate capitalized class names\n        // for React-like components, e.g. `Foo.Bar.Baz`\n        while (readable(scanner)) {\n            const { pos } = scanner;\n            if (!consume(scanner, isClassNameOperator) || !consume(scanner, isCapitalizedLiteral)) {\n                scanner.pos = pos;\n                break;\n            }\n        }\n    }\n    while (readable(scanner) && consume(scanner, isElementName$1)) {\n        // empty\n    }\n    if (scanner.pos !== start) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes text value from given scanner\n */\nfunction text(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isTextStart)) {\n        let brackets = 0;\n        while (readable(scanner)) {\n            const token = next(scanner);\n            if (isBracket(token, 'expression')) {\n                if (token.open) {\n                    brackets++;\n                }\n                else if (!brackets) {\n                    break;\n                }\n                else {\n                    brackets--;\n                }\n            }\n        }\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\nfunction getText(scanner) {\n    let from = scanner.start;\n    let to = scanner.pos;\n    if (isBracket(scanner.tokens[from], 'expression', true)) {\n        from++;\n    }\n    if (isBracket(scanner.tokens[to - 1], 'expression', false)) {\n        to--;\n    }\n    return slice(scanner, from, to);\n}\nfunction isBracket(token, context, isOpen) {\n    return Boolean(token && token.type === 'Bracket'\n        && (!context || token.context === context)\n        && (isOpen == null || token.open === isOpen));\n}\nfunction isOperator(token, type) {\n    return Boolean(token && token.type === 'Operator' && (!type || token.operator === type));\n}\nfunction isQuote(token, isSingle) {\n    return Boolean(token && token.type === 'Quote' && (isSingle == null || token.single === isSingle));\n}\nfunction isWhiteSpace(token) {\n    return Boolean(token && token.type === 'WhiteSpace');\n}\nfunction isEquals(token) {\n    return isOperator(token, 'equal');\n}\nfunction isRepeater(token) {\n    return Boolean(token && token.type === 'Repeater');\n}\nfunction isLiteral(token) {\n    return token.type === 'Literal';\n}\nfunction isCapitalizedLiteral(token) {\n    if (isLiteral(token)) {\n        const ch = token.value.charCodeAt(0);\n        return ch >= 65 && ch <= 90;\n    }\n    return false;\n}\nfunction isElementName$1(token) {\n    return token.type === 'Literal' || token.type === 'RepeaterNumber' || token.type === 'RepeaterPlaceholder';\n}\nfunction isClassNameOperator(token) {\n    return isOperator(token, 'class');\n}\nfunction isAttributeSetStart(token) {\n    return isBracket(token, 'attribute', true);\n}\nfunction isAttributeSetEnd(token) {\n    return isBracket(token, 'attribute', false);\n}\nfunction isTextStart(token) {\n    return isBracket(token, 'expression', true);\n}\nfunction isGroupStart(token) {\n    return isBracket(token, 'group', true);\n}\nfunction createLiteral(value) {\n    return { type: 'Literal', value };\n}\nfunction isEmpty(elem) {\n    return !elem.name && !elem.value && !elem.attributes;\n}\nfunction isChildOperator(token) {\n    return isOperator(token, 'child');\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, 'sibling');\n}\nfunction isClimbOperator(token) {\n    return isOperator(token, 'climb');\n}\nfunction isCloseOperator(token) {\n    return isOperator(token, 'close');\n}\n\nvar Chars;\n(function (Chars) {\n    /** `{` character */\n    Chars[Chars[\"CurlyBracketOpen\"] = 123] = \"CurlyBracketOpen\";\n    /** `}` character */\n    Chars[Chars[\"CurlyBracketClose\"] = 125] = \"CurlyBracketClose\";\n    /** `\\\\` character */\n    Chars[Chars[\"Escape\"] = 92] = \"Escape\";\n    /** `=` character */\n    Chars[Chars[\"Equals\"] = 61] = \"Equals\";\n    /** `[` character */\n    Chars[Chars[\"SquareBracketOpen\"] = 91] = \"SquareBracketOpen\";\n    /** `]` character */\n    Chars[Chars[\"SquareBracketClose\"] = 93] = \"SquareBracketClose\";\n    /** `*` character */\n    Chars[Chars[\"Asterisk\"] = 42] = \"Asterisk\";\n    /** `#` character */\n    Chars[Chars[\"Hash\"] = 35] = \"Hash\";\n    /** `$` character */\n    Chars[Chars[\"Dollar\"] = 36] = \"Dollar\";\n    /** `-` character */\n    Chars[Chars[\"Dash\"] = 45] = \"Dash\";\n    /** `.` character */\n    Chars[Chars[\"Dot\"] = 46] = \"Dot\";\n    /** `/` character */\n    Chars[Chars[\"Slash\"] = 47] = \"Slash\";\n    /** `:` character */\n    Chars[Chars[\"Colon\"] = 58] = \"Colon\";\n    /** `!` character */\n    Chars[Chars[\"Excl\"] = 33] = \"Excl\";\n    /** `@` character */\n    Chars[Chars[\"At\"] = 64] = \"At\";\n    /** `_` character */\n    Chars[Chars[\"Underscore\"] = 95] = \"Underscore\";\n    /** `(` character */\n    Chars[Chars[\"RoundBracketOpen\"] = 40] = \"RoundBracketOpen\";\n    /** `)` character */\n    Chars[Chars[\"RoundBracketClose\"] = 41] = \"RoundBracketClose\";\n    /** `+` character */\n    Chars[Chars[\"Sibling\"] = 43] = \"Sibling\";\n    /** `>` character */\n    Chars[Chars[\"Child\"] = 62] = \"Child\";\n    /** `^` character */\n    Chars[Chars[\"Climb\"] = 94] = \"Climb\";\n    /** `'` character */\n    Chars[Chars[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    /** `\"\"` character */\n    Chars[Chars[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n})(Chars || (Chars = {}));\n/**\n * If consumes escape character, sets current stream range to escaped value\n */\nfunction escaped(scanner) {\n    if (scanner.eat(Chars.Escape)) {\n        scanner.start = scanner.pos;\n        if (!scanner.eof()) {\n            scanner.pos++;\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction tokenize(source) {\n    const scanner = new Scanner(source);\n    const result = [];\n    const ctx = {\n        group: 0,\n        attribute: 0,\n        expression: 0,\n        quote: 0\n    };\n    let ch = 0;\n    let token;\n    while (!scanner.eof()) {\n        ch = scanner.peek();\n        token = getToken(scanner, ctx);\n        if (token) {\n            result.push(token);\n            if (token.type === 'Quote') {\n                ctx.quote = ch === ctx.quote ? 0 : ch;\n            }\n            else if (token.type === 'Bracket') {\n                ctx[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else {\n            throw scanner.error('Unexpected character');\n        }\n    }\n    return result;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, ctx) {\n    return field(scanner, ctx)\n        || repeaterPlaceholder(scanner)\n        || repeaterNumber(scanner)\n        || repeater(scanner)\n        || whiteSpace(scanner)\n        || literal(scanner, ctx)\n        || operator(scanner)\n        || quote(scanner)\n        || bracket(scanner);\n}\n/**\n * Consumes literal from given scanner\n */\nfunction literal(scanner, ctx) {\n    const start = scanner.pos;\n    const expressionStart = ctx.expression;\n    let value = '';\n    while (!scanner.eof()) {\n        // Consume escaped sequence no matter of context\n        if (escaped(scanner)) {\n            value += scanner.current();\n            continue;\n        }\n        const ch = scanner.peek();\n        if (ch === Chars.Slash && !ctx.quote && !ctx.expression && !ctx.attribute) {\n            // Special case for `/` character between numbers in class names\n            const prev = scanner.string.charCodeAt(scanner.pos - 1);\n            const next = scanner.string.charCodeAt(scanner.pos + 1);\n            if (isNumber(prev) && isNumber(next)) {\n                value += scanner.string[scanner.pos++];\n                continue;\n            }\n        }\n        if (ch === ctx.quote || ch === Chars.Dollar || isAllowedOperator(ch, ctx)) {\n            // 1. Found matching quote\n            // 2. The `$` character has special meaning in every context\n            // 3. Depending on context, some characters should be treated as operators\n            break;\n        }\n        if (expressionStart) {\n            // Consume nested expressions, e.g. span{{foo}}\n            if (ch === Chars.CurlyBracketOpen) {\n                ctx.expression++;\n            }\n            else if (ch === Chars.CurlyBracketClose) {\n                if (ctx.expression > expressionStart) {\n                    ctx.expression--;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        else if (!ctx.quote) {\n            // Consuming element name\n            if (!ctx.attribute && !isElementName(ch)) {\n                break;\n            }\n            if (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote$1(ch) || bracketType(ch)) {\n                // Stop for characters not allowed in unquoted literal\n                break;\n            }\n        }\n        value += scanner.string[scanner.pos++];\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return {\n            type: 'Literal',\n            value,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos,\n            value: scanner.substring(start, scanner.pos)\n        };\n    }\n}\n/**\n * Consumes quote from given scanner\n */\nfunction quote(scanner) {\n    const ch = scanner.peek();\n    if (isQuote$1(ch)) {\n        return {\n            type: 'Quote',\n            single: ch === Chars.SingleQuote,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    const context = bracketType(ch);\n    if (context) {\n        return {\n            type: 'Bracket',\n            open: isOpenBracket(ch),\n            context,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n */\nfunction repeater(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars.Asterisk)) {\n        scanner.start = scanner.pos;\n        let count = 1;\n        let implicit = false;\n        if (scanner.eatWhile(isNumber)) {\n            count = Number(scanner.current());\n        }\n        else {\n            implicit = true;\n        }\n        return {\n            type: 'Repeater',\n            count,\n            value: 0,\n            implicit,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes repeater placeholder `$#` from given scanner\n */\nfunction repeaterPlaceholder(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars.Dollar) && scanner.eat(Chars.Hash)) {\n        return {\n            type: 'RepeaterPlaceholder',\n            value: void 0,\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes numbering token like `$` from given scanner state\n */\nfunction repeaterNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(Chars.Dollar)) {\n        const size = scanner.pos - start;\n        let reverse = false;\n        let base = 1;\n        let parent = 0;\n        if (scanner.eat(Chars.At)) {\n            // Consume numbering modifiers\n            while (scanner.eat(Chars.Climb)) {\n                parent++;\n            }\n            reverse = scanner.eat(Chars.Dash);\n            scanner.start = scanner.pos;\n            if (scanner.eatWhile(isNumber)) {\n                base = Number(scanner.current());\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'RepeaterNumber',\n            size,\n            reverse,\n            base,\n            parent,\n            start,\n            end: scanner.pos\n        };\n    }\n}\nfunction field(scanner, ctx) {\n    const start = scanner.pos;\n    // Fields are allowed inside expressions and attributes\n    if ((ctx.expression || ctx.attribute) && scanner.eat(Chars.Dollar) && scanner.eat(Chars.CurlyBracketOpen)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(Chars.Colon) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(Chars.CurlyBracketClose)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(Chars.CurlyBracketOpen)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(Chars.CurlyBracketClose)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Check if given character code is an operator and it’s allowed in current context\n */\nfunction isAllowedOperator(ch, ctx) {\n    const op = operatorType(ch);\n    if (!op || ctx.quote || ctx.expression) {\n        // No operators inside quoted values or expressions\n        return false;\n    }\n    // Inside attributes, only `equals` is allowed\n    return !ctx.attribute || op === 'equal';\n}\n/**\n * Check if given character is a space character and is allowed to be consumed\n * as a space token in current context\n */\nfunction isAllowedSpace(ch, ctx) {\n    return isSpace(ch) && !ctx.expression;\n}\n/**\n * Check if given character can be consumed as repeater in current context\n */\nfunction isAllowedRepeater(ch, ctx) {\n    return ch === Chars.Asterisk && !ctx.attribute && !ctx.expression;\n}\n/**\n * If given character is a bracket, returns it’s type\n */\nfunction bracketType(ch) {\n    if (ch === Chars.RoundBracketOpen || ch === Chars.RoundBracketClose) {\n        return 'group';\n    }\n    if (ch === Chars.SquareBracketOpen || ch === Chars.SquareBracketClose) {\n        return 'attribute';\n    }\n    if (ch === Chars.CurlyBracketOpen || ch === Chars.CurlyBracketClose) {\n        return 'expression';\n    }\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === Chars.Child && 'child')\n        || (ch === Chars.Sibling && 'sibling')\n        || (ch === Chars.Climb && 'climb')\n        || (ch === Chars.Dot && 'class')\n        || (ch === Chars.Hash && 'id')\n        || (ch === Chars.Slash && 'close')\n        || (ch === Chars.Equals && 'equal')\n        || void 0;\n}\n/**\n * Check if given character is an open bracket\n */\nfunction isOpenBracket(ch) {\n    return ch === Chars.CurlyBracketOpen\n        || ch === Chars.SquareBracketOpen\n        || ch === Chars.RoundBracketOpen;\n}\n/**\n * Check if given character is allowed in element name\n */\nfunction isElementName(ch) {\n    return isAlphaNumericWord(ch)\n        || isUmlaut(ch)\n        || ch === Chars.Dash\n        || ch === Chars.Colon\n        || ch === Chars.Excl;\n}\n\nconst operators = {\n    child: '>',\n    class: '.',\n    climb: '^',\n    id: '#',\n    equal: '=',\n    close: '/',\n    sibling: '+'\n};\nconst tokenVisitor = {\n    Literal(token) {\n        return token.value;\n    },\n    Quote(token) {\n        return token.single ? '\\'' : '\"';\n    },\n    Bracket(token) {\n        if (token.context === 'attribute') {\n            return token.open ? '[' : ']';\n        }\n        else if (token.context === 'expression') {\n            return token.open ? '{' : '}';\n        }\n        else {\n            return token.open ? '(' : '}';\n        }\n    },\n    Operator(token) {\n        return operators[token.operator];\n    },\n    Field(token, state) {\n        if (token.index != null) {\n            // It’s a field: by default, return TextMate-compatible field\n            return token.name\n                ? `\\${${token.index}:${token.name}}`\n                : `\\${${token.index}`;\n        }\n        else if (token.name) {\n            // It’s a variable\n            return state.getVariable(token.name);\n        }\n        return '';\n    },\n    RepeaterPlaceholder(token, state) {\n        // Find closest implicit repeater\n        let repeater;\n        for (let i = state.repeaters.length - 1; i >= 0; i--) {\n            if (state.repeaters[i].implicit) {\n                repeater = state.repeaters[i];\n                break;\n            }\n        }\n        state.inserted = true;\n        return state.getText(repeater && repeater.value);\n    },\n    RepeaterNumber(token, state) {\n        let value = 1;\n        const lastIx = state.repeaters.length - 1;\n        // const repeaterIx = Math.max(0, state.repeaters.length - 1 - token.parent);\n        const repeater = state.repeaters[lastIx];\n        if (repeater) {\n            value = token.reverse\n                ? token.base + repeater.count - repeater.value - 1\n                : token.base + repeater.value;\n            if (token.parent) {\n                const parentIx = Math.max(0, lastIx - token.parent);\n                if (parentIx !== lastIx) {\n                    const parentRepeater = state.repeaters[parentIx];\n                    value += repeater.count * parentRepeater.value;\n                }\n            }\n        }\n        let result = String(value);\n        while (result.length < token.size) {\n            result = '0' + result;\n        }\n        return result;\n    },\n    WhiteSpace(token) {\n        return token.value;\n    }\n};\n/**\n * Converts given value token to string\n */\nfunction stringify(token, state) {\n    if (!tokenVisitor[token.type]) {\n        throw new Error(`Unknown token ${token.type}`);\n    }\n    return tokenVisitor[token.type](token, state);\n}\n\nconst urlRegex = /^((https?:|ftp:|file:)?\\/\\/|(www|ftp)\\.)[^ ]*$/;\nconst emailRegex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,5}$/;\n/**\n * Converts given token-based abbreviation into simplified and unrolled node-based\n * abbreviation\n */\nfunction convert(abbr, options = {}) {\n    let textInserted = false;\n    let cleanText;\n    if (options.text) {\n        if (Array.isArray(options.text)) {\n            cleanText = options.text.filter(s => s.trim());\n        }\n        else {\n            cleanText = options.text;\n        }\n    }\n    const result = {\n        type: 'Abbreviation',\n        children: convertGroup(abbr, {\n            inserted: false,\n            repeaters: [],\n            text: options.text,\n            cleanText,\n            repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,\n            getText(pos) {\n                var _a;\n                textInserted = true;\n                let value;\n                if (Array.isArray(options.text)) {\n                    if (pos !== undefined && pos >= 0 && pos < cleanText.length) {\n                        return cleanText[pos];\n                    }\n                    value = pos !== undefined ? options.text[pos] : options.text.join('\\n');\n                }\n                else {\n                    value = (_a = options.text) !== null && _a !== void 0 ? _a : '';\n                }\n                return value;\n            },\n            getVariable(name) {\n                const varValue = options.variables && options.variables[name];\n                return varValue != null ? varValue : name;\n            }\n        })\n    };\n    if (options.text != null && !textInserted) {\n        // Text given but no implicitly repeated elements: insert it into\n        // deepest child\n        const deepest = deepestNode(last(result.children));\n        if (deepest) {\n            const text = Array.isArray(options.text) ? options.text.join('\\n') : options.text;\n            insertText(deepest, text);\n            if (deepest.name === 'a' && options.href) {\n                // Automatically update value of `<a>` element if inserting URL or email\n                insertHref(deepest, text);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Converts given statement to abbreviation nodes\n */\nfunction convertStatement(node, state) {\n    let result = [];\n    if (node.repeat) {\n        // Node is repeated: we should create copies of given node\n        // and supply context token with actual repeater state\n        const original = node.repeat;\n        const repeat = Object.assign({}, original);\n        repeat.count = repeat.implicit && Array.isArray(state.text)\n            ? state.cleanText.length\n            : (repeat.count || 1);\n        let items;\n        state.repeaters.push(repeat);\n        for (let i = 0; i < repeat.count; i++) {\n            repeat.value = i;\n            node.repeat = repeat;\n            items = isGroup(node)\n                ? convertGroup(node, state)\n                : convertElement(node, state);\n            if (repeat.implicit && !state.inserted) {\n                // It’s an implicit repeater but no repeater placeholders found inside,\n                // we should insert text into deepest node\n                const target = last(items);\n                const deepest = target && deepestNode(target);\n                if (deepest) {\n                    insertText(deepest, state.getText(repeat.value));\n                }\n            }\n            result = result.concat(items);\n            // We should output at least one repeated item even if it’s reached\n            // repeat limit\n            if (--state.repeatGuard <= 0) {\n                break;\n            }\n        }\n        state.repeaters.pop();\n        node.repeat = original;\n        if (repeat.implicit) {\n            state.inserted = true;\n        }\n    }\n    else {\n        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));\n    }\n    return result;\n}\nfunction convertElement(node, state) {\n    let children = [];\n    const elem = {\n        type: 'AbbreviationNode',\n        name: node.name && stringifyName(node.name, state),\n        value: node.value && stringifyValue(node.value, state),\n        attributes: void 0,\n        children,\n        repeat: node.repeat && Object.assign({}, node.repeat),\n        selfClosing: node.selfClose,\n    };\n    let result = [elem];\n    for (const child of node.elements) {\n        children = children.concat(convertStatement(child, state));\n    }\n    if (node.attributes) {\n        elem.attributes = [];\n        for (const attr of node.attributes) {\n            elem.attributes.push(convertAttribute(attr, state));\n        }\n    }\n    // In case if current node is a text-only snippet without fields, we should\n    // put all children as siblings\n    if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField)) {\n        // XXX it’s unclear that `children` is not bound to `elem`\n        // due to concat operation\n        result = result.concat(children);\n    }\n    else {\n        elem.children = children;\n    }\n    return result;\n}\nfunction convertGroup(node, state) {\n    let result = [];\n    for (const child of node.elements) {\n        result = result.concat(convertStatement(child, state));\n    }\n    if (node.repeat) {\n        result = attachRepeater(result, node.repeat);\n    }\n    return result;\n}\nfunction convertAttribute(node, state) {\n    let implied = false;\n    let isBoolean = false;\n    let valueType = node.expression ? 'expression' : 'raw';\n    let value;\n    const name = node.name && stringifyName(node.name, state);\n    if (name && name[0] === '!') {\n        implied = true;\n    }\n    if (name && name[name.length - 1] === '.') {\n        isBoolean = true;\n    }\n    if (node.value) {\n        const tokens = node.value.slice();\n        if (isQuote(tokens[0])) {\n            // It’s a quoted value: remove quotes from output but mark attribute\n            // value as quoted\n            const quote = tokens.shift();\n            if (tokens.length && last(tokens).type === quote.type) {\n                tokens.pop();\n            }\n            valueType = quote.single ? 'singleQuote' : 'doubleQuote';\n        }\n        else if (isBracket(tokens[0], 'expression', true)) {\n            // Value is expression: remove brackets but mark value type\n            valueType = 'expression';\n            tokens.shift();\n            if (isBracket(last(tokens), 'expression', false)) {\n                tokens.pop();\n            }\n        }\n        value = stringifyValue(tokens, state);\n    }\n    return {\n        name: isBoolean || implied\n            ? name.slice(implied ? 1 : 0, isBoolean ? -1 : void 0)\n            : name,\n        value,\n        boolean: isBoolean,\n        implied,\n        valueType,\n        multiple: node.multiple\n    };\n}\n/**\n * Converts given token list to string\n */\nfunction stringifyName(tokens, state) {\n    let str = '';\n    for (let i = 0; i < tokens.length; i++) {\n        str += stringify(tokens[i], state);\n    }\n    return str;\n}\n/**\n * Converts given token list to value list\n */\nfunction stringifyValue(tokens, state) {\n    const result = [];\n    let str = '';\n    for (let i = 0, token; i < tokens.length; i++) {\n        token = tokens[i];\n        if (isField(token)) {\n            // We should keep original fields in output since some editors has their\n            // own syntax for field or doesn’t support fields at all so we should\n            // capture actual field location in output stream\n            if (str) {\n                result.push(str);\n                str = '';\n            }\n            result.push(token);\n        }\n        else {\n            str += stringify(token, state);\n        }\n    }\n    if (str) {\n        result.push(str);\n    }\n    return result;\n}\nfunction isGroup(node) {\n    return node.type === 'TokenGroup';\n}\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field' && token.index != null;\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nfunction deepestNode(node) {\n    return node.children.length ? deepestNode(last(node.children)) : node;\n}\nfunction insertText(node, text) {\n    if (node.value) {\n        const lastToken = last(node.value);\n        if (typeof lastToken === 'string') {\n            node.value[node.value.length - 1] += text;\n        }\n        else {\n            node.value.push(text);\n        }\n    }\n    else {\n        node.value = [text];\n    }\n}\nfunction insertHref(node, text) {\n    var _a;\n    let href = '';\n    if (urlRegex.test(text)) {\n        href = text;\n        if (!/\\w+:/.test(href) && !href.startsWith('//')) {\n            href = `http://${href}`;\n        }\n    }\n    else if (emailRegex.test(text)) {\n        href = `mailto:${text}`;\n    }\n    const hrefAttribute = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.find(attr => attr.name === 'href');\n    if (!hrefAttribute) {\n        if (!node.attributes) {\n            node.attributes = [];\n        }\n        node.attributes.push({ name: 'href', value: [href], valueType: 'doubleQuote' });\n    }\n    else if (!hrefAttribute.value) {\n        hrefAttribute.value = [href];\n    }\n}\nfunction attachRepeater(items, repeater) {\n    for (const item of items) {\n        if (!item.repeat) {\n            item.repeat = Object.assign({}, repeater);\n        }\n    }\n    return items;\n}\n\n/**\n * Parses given abbreviation into node tree\n */\nfunction parseAbbreviation(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr) : abbr;\n        return convert(abbreviation(tokens, options), options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport { convert, parseAbbreviation as default, getToken, abbreviation as parse, tokenize };\n//# sourceMappingURL=index.js.map\n","import Scanner, { isNumber, isAlpha, isAlphaWord, isQuote, isSpace, isAlphaNumericWord, ScannerError } from '@emmetio/scanner';\n\nvar OperatorType;\n(function (OperatorType) {\n    OperatorType[\"Sibling\"] = \"+\";\n    OperatorType[\"Important\"] = \"!\";\n    OperatorType[\"ArgumentDelimiter\"] = \",\";\n    OperatorType[\"ValueDelimiter\"] = \"-\";\n    OperatorType[\"PropertyDelimiter\"] = \":\";\n})(OperatorType || (OperatorType = {}));\n\nvar Chars;\n(function (Chars) {\n    /** `#` character */\n    Chars[Chars[\"Hash\"] = 35] = \"Hash\";\n    /** `$` character */\n    Chars[Chars[\"Dollar\"] = 36] = \"Dollar\";\n    /** `-` character */\n    Chars[Chars[\"Dash\"] = 45] = \"Dash\";\n    /** `.` character */\n    Chars[Chars[\"Dot\"] = 46] = \"Dot\";\n    /** `:` character */\n    Chars[Chars[\"Colon\"] = 58] = \"Colon\";\n    /** `,` character */\n    Chars[Chars[\"Comma\"] = 44] = \"Comma\";\n    /** `!` character */\n    Chars[Chars[\"Excl\"] = 33] = \"Excl\";\n    /** `@` character */\n    Chars[Chars[\"At\"] = 64] = \"At\";\n    /** `%` character */\n    Chars[Chars[\"Percent\"] = 37] = \"Percent\";\n    /** `_` character */\n    Chars[Chars[\"Underscore\"] = 95] = \"Underscore\";\n    /** `(` character */\n    Chars[Chars[\"RoundBracketOpen\"] = 40] = \"RoundBracketOpen\";\n    /** `)` character */\n    Chars[Chars[\"RoundBracketClose\"] = 41] = \"RoundBracketClose\";\n    /** `{` character */\n    Chars[Chars[\"CurlyBracketOpen\"] = 123] = \"CurlyBracketOpen\";\n    /** `}` character */\n    Chars[Chars[\"CurlyBracketClose\"] = 125] = \"CurlyBracketClose\";\n    /** `+` character */\n    Chars[Chars[\"Sibling\"] = 43] = \"Sibling\";\n    /** `'` character */\n    Chars[Chars[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    /** `\"` character */\n    Chars[Chars[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n    /** `t` character */\n    Chars[Chars[\"Transparent\"] = 116] = \"Transparent\";\n    /** `/` character */\n    Chars[Chars[\"Slash\"] = 47] = \"Slash\";\n})(Chars || (Chars = {}));\n\nfunction tokenize(abbr, isValue) {\n    let brackets = 0;\n    let token;\n    const scanner = new Scanner(abbr);\n    const tokens = [];\n    while (!scanner.eof()) {\n        token = getToken(scanner, brackets === 0 && !isValue);\n        if (!token) {\n            throw scanner.error('Unexpected character');\n        }\n        if (token.type === 'Bracket') {\n            if (!brackets && token.open) {\n                mergeTokens(scanner, tokens);\n            }\n            brackets += token.open ? 1 : -1;\n            if (brackets < 0) {\n                throw scanner.error('Unexpected bracket', token.start);\n            }\n        }\n        tokens.push(token);\n        // Forcibly consume next operator after unit-less numeric value or color:\n        // next dash `-` must be used as value delimiter\n        if (shouldConsumeDashAfter(token) && (token = operator(scanner))) {\n            tokens.push(token);\n        }\n    }\n    return tokens;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, short) {\n    return field(scanner)\n        || customProperty(scanner)\n        || numberValue(scanner)\n        || colorValue(scanner)\n        || stringValue(scanner)\n        || bracket(scanner)\n        || operator(scanner)\n        || whiteSpace(scanner)\n        || literal(scanner, short);\n}\nfunction field(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars.Dollar) && scanner.eat(Chars.CurlyBracketOpen)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(Chars.Colon) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(Chars.CurlyBracketClose)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(Chars.CurlyBracketOpen)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(Chars.CurlyBracketClose)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Consumes literal from given scanner\n * @param short Use short notation for consuming value.\n * The difference between “short” and “full” notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while “full” notation also supports numbers and dashes\n */\nfunction literal(scanner, short) {\n    const start = scanner.pos;\n    if (scanner.eat(isIdentPrefix)) {\n        // SCSS or LESS variable\n        // NB a bit dirty hack: if abbreviation starts with identifier prefix,\n        // consume alpha characters only to allow embedded variables\n        scanner.eatWhile(start ? isKeyword : isLiteral$1);\n    }\n    else if (scanner.eat(isAlphaWord)) {\n        scanner.eatWhile(short ? isLiteral$1 : isKeyword);\n    }\n    else {\n        // Allow dots only at the beginning of literal\n        scanner.eat(Chars.Dot);\n        scanner.eatWhile(isLiteral$1);\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return createLiteral(scanner, scanner.start = start);\n    }\n}\nfunction createLiteral(scanner, start = scanner.start, end = scanner.pos) {\n    return {\n        type: 'Literal',\n        value: scanner.substring(start, end),\n        start,\n        end\n    };\n}\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n */\nfunction numberValue(scanner) {\n    const start = scanner.pos;\n    if (consumeNumber(scanner)) {\n        scanner.start = start;\n        const rawValue = scanner.current();\n        // eat unit, which can be a % or alpha word\n        scanner.start = scanner.pos;\n        scanner.eat(Chars.Percent) || scanner.eatWhile(isAlphaWord);\n        return {\n            type: 'NumberValue',\n            value: Number(rawValue),\n            rawValue,\n            unit: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quoted string value from given scanner\n */\nfunction stringValue(scanner) {\n    const ch = scanner.peek();\n    const start = scanner.pos;\n    let finished = false;\n    if (isQuote(ch)) {\n        scanner.pos++;\n        while (!scanner.eof()) {\n            // Do not throw error on malformed string\n            if (scanner.eat(ch)) {\n                finished = true;\n                break;\n            }\n            else {\n                scanner.pos++;\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'StringValue',\n            value: scanner.substring(start + 1, scanner.pos - (finished ? 1 : 0)),\n            quote: ch === Chars.SingleQuote ? 'single' : 'double',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes a color token from given string\n */\nfunction colorValue(scanner) {\n    // supported color variations:\n    // #abc   → #aabbccc\n    // #0     → #000000\n    // #fff.5 → rgba(255, 255, 255, 0.5)\n    // #t     → transparent\n    const start = scanner.pos;\n    if (scanner.eat(Chars.Hash)) {\n        const valueStart = scanner.pos;\n        let color = '';\n        let alpha = '';\n        if (scanner.eatWhile(isHex)) {\n            color = scanner.substring(valueStart, scanner.pos);\n            alpha = colorAlpha(scanner);\n        }\n        else if (scanner.eat(Chars.Transparent)) {\n            color = '0';\n            alpha = colorAlpha(scanner) || '0';\n        }\n        else {\n            alpha = colorAlpha(scanner);\n        }\n        if (color || alpha || scanner.eof()) {\n            const { r, g, b, a } = parseColor(color, alpha);\n            return {\n                type: 'ColorValue',\n                r, g, b, a,\n                raw: scanner.substring(start + 1, scanner.pos),\n                start,\n                end: scanner.pos\n            };\n        }\n        else {\n            // Consumed # but no actual value: invalid color value, treat it as literal\n            return createLiteral(scanner, start);\n        }\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes alpha value of color: `.1`\n */\nfunction colorAlpha(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars.Dot)) {\n        scanner.start = start;\n        if (scanner.eatWhile(isNumber)) {\n            return scanner.current();\n        }\n        return '1';\n    }\n    return '';\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes custom CSS property: --foo-bar\n */\nfunction customProperty(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars.Dash) && scanner.eat(Chars.Dash)) {\n        scanner.start = start;\n        scanner.eatWhile(isKeyword);\n        return {\n            type: 'CustomProperty',\n            value: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    if (isBracket$1(ch)) {\n        return {\n            type: 'Bracket',\n            open: ch === Chars.RoundBracketOpen,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Eats number value from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(stream) {\n    const start = stream.pos;\n    stream.eat(Chars.Dash);\n    const afterNegative = stream.pos;\n    const hasDecimal = stream.eatWhile(isNumber);\n    const prevPos = stream.pos;\n    if (stream.eat(Chars.Dot)) {\n        // It’s perfectly valid to have numbers like `1.`, which enforces\n        // value to float unit type\n        const hasFloat = stream.eatWhile(isNumber);\n        if (!hasDecimal && !hasFloat) {\n            // Lone dot\n            stream.pos = prevPos;\n        }\n    }\n    // Edge case: consumed dash only: not a number, bail-out\n    if (stream.pos === afterNegative) {\n        stream.pos = start;\n    }\n    return stream.pos !== start;\n}\nfunction isIdentPrefix(code) {\n    return code === Chars.At || code === Chars.Dollar;\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === Chars.Sibling && OperatorType.Sibling)\n        || (ch === Chars.Excl && OperatorType.Important)\n        || (ch === Chars.Comma && OperatorType.ArgumentDelimiter)\n        || (ch === Chars.Colon && OperatorType.PropertyDelimiter)\n        || (ch === Chars.Dash && OperatorType.ValueDelimiter)\n        || void 0;\n}\n/**\n * Check if given code is a hex value (/0-9a-f/)\n */\nfunction isHex(code) {\n    return isNumber(code) || isAlpha(code, 65, 70); // A-F\n}\nfunction isKeyword(code) {\n    return isAlphaNumericWord(code) || code === Chars.Dash;\n}\nfunction isBracket$1(code) {\n    return code === Chars.RoundBracketOpen || code === Chars.RoundBracketClose;\n}\nfunction isLiteral$1(code) {\n    return isAlphaWord(code) || code === Chars.Percent || code === Chars.Slash;\n}\n/**\n * Parses given color value from abbreviation into RGBA format\n */\nfunction parseColor(value, alpha) {\n    let r = '0';\n    let g = '0';\n    let b = '0';\n    let a = Number(alpha != null && alpha !== '' ? alpha : 1);\n    if (value === 't') {\n        a = 0;\n    }\n    else {\n        switch (value.length) {\n            case 0:\n                break;\n            case 1:\n                r = g = b = value + value;\n                break;\n            case 2:\n                r = g = b = value;\n                break;\n            case 3:\n                r = value[0] + value[0];\n                g = value[1] + value[1];\n                b = value[2] + value[2];\n                break;\n            default:\n                value += value;\n                r = value.slice(0, 2);\n                g = value.slice(2, 4);\n                b = value.slice(4, 6);\n        }\n    }\n    return {\n        r: parseInt(r, 16),\n        g: parseInt(g, 16),\n        b: parseInt(b, 16),\n        a\n    };\n}\n/**\n * Check if scanner reader must consume dash after given token.\n * Used in cases where user must explicitly separate numeric values\n */\nfunction shouldConsumeDashAfter(token) {\n    return token.type === 'ColorValue' || (token.type === 'NumberValue' && !token.unit);\n}\n/**\n * Merges last adjacent tokens into a single literal.\n * This function is used to overcome edge case when function name was parsed\n * as a list of separate tokens. For example, a `scale3d()` value will be\n * parsed as literal and number tokens (`scale` and `3d`) which is a perfectly\n * valid abbreviation but undesired result. This function will detect last adjacent\n * literal and number values and combine them into single literal\n */\nfunction mergeTokens(scanner, tokens) {\n    let start = 0;\n    let end = 0;\n    while (tokens.length) {\n        const token = last(tokens);\n        if (token.type === 'Literal' || token.type === 'NumberValue') {\n            start = token.start;\n            if (!end) {\n                end = token.end;\n            }\n            tokens.pop();\n        }\n        else {\n            break;\n        }\n    }\n    if (start !== end) {\n        tokens.push(createLiteral(scanner, start, end));\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    if (test(peek(scanner))) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction parser(tokens, options = {}) {\n    const scanner = tokenScanner(tokens);\n    const result = [];\n    let property;\n    while (readable(scanner)) {\n        if (property = consumeProperty(scanner, options)) {\n            result.push(property);\n        }\n        else if (!consume(scanner, isSiblingOperator)) {\n            throw error(scanner, 'Unexpected token');\n        }\n    }\n    return result;\n}\n/**\n * Consumes single CSS property\n */\nfunction consumeProperty(scanner, options) {\n    let name;\n    let important = false;\n    let valueFragment;\n    const value = [];\n    const token = peek(scanner);\n    const valueMode = !!options.value;\n    if (!valueMode && isLiteral(token) && !isFunctionStart(scanner)) {\n        scanner.pos++;\n        name = token.value;\n        // Consume any following value delimiter after property name\n        consume(scanner, isValueDelimiter);\n    }\n    // Skip whitespace right after property name, if any\n    if (valueMode) {\n        consume(scanner, isWhiteSpace);\n    }\n    while (readable(scanner)) {\n        if (consume(scanner, isImportant)) {\n            important = true;\n        }\n        else if (valueFragment = consumeValue(scanner, valueMode)) {\n            value.push(valueFragment);\n        }\n        else if (!consume(scanner, isFragmentDelimiter)) {\n            break;\n        }\n    }\n    if (name || value.length || important) {\n        return { name, value, important };\n    }\n}\n/**\n * Consumes single value fragment, e.g. all value tokens before comma\n */\nfunction consumeValue(scanner, inArgument) {\n    const result = [];\n    let token;\n    let args;\n    while (readable(scanner)) {\n        token = peek(scanner);\n        if (isValue(token)) {\n            scanner.pos++;\n            if (isLiteral(token) && (args = consumeArguments(scanner))) {\n                result.push({\n                    type: 'FunctionCall',\n                    name: token.value,\n                    arguments: args\n                });\n            }\n            else {\n                result.push(token);\n            }\n        }\n        else if (isValueDelimiter(token) || (inArgument && isWhiteSpace(token))) {\n            scanner.pos++;\n        }\n        else {\n            break;\n        }\n    }\n    return result.length\n        ? { type: 'CSSValue', value: result }\n        : void 0;\n}\nfunction consumeArguments(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isOpenBracket)) {\n        const args = [];\n        let value;\n        while (readable(scanner) && !consume(scanner, isCloseBracket)) {\n            if (value = consumeValue(scanner, true)) {\n                args.push(value);\n            }\n            else if (!consume(scanner, isWhiteSpace) && !consume(scanner, isArgumentDelimiter)) {\n                throw error(scanner, 'Unexpected token');\n            }\n        }\n        scanner.start = start;\n        return args;\n    }\n}\nfunction isLiteral(token) {\n    return token && token.type === 'Literal';\n}\nfunction isBracket(token, open) {\n    return token && token.type === 'Bracket' && (open == null || token.open === open);\n}\nfunction isOpenBracket(token) {\n    return isBracket(token, true);\n}\nfunction isCloseBracket(token) {\n    return isBracket(token, false);\n}\nfunction isWhiteSpace(token) {\n    return token && token.type === 'WhiteSpace';\n}\nfunction isOperator(token, operator) {\n    return token && token.type === 'Operator' && (!operator || token.operator === operator);\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, OperatorType.Sibling);\n}\nfunction isArgumentDelimiter(token) {\n    return isOperator(token, OperatorType.ArgumentDelimiter);\n}\nfunction isFragmentDelimiter(token) {\n    return isArgumentDelimiter(token);\n}\nfunction isImportant(token) {\n    return isOperator(token, OperatorType.Important);\n}\nfunction isValue(token) {\n    return token.type === 'StringValue'\n        || token.type === 'ColorValue'\n        || token.type === 'NumberValue'\n        || token.type === 'Literal'\n        || token.type === 'Field'\n        || token.type === 'CustomProperty';\n}\nfunction isValueDelimiter(token) {\n    return isOperator(token, OperatorType.PropertyDelimiter)\n        || isOperator(token, OperatorType.ValueDelimiter);\n}\nfunction isFunctionStart(scanner) {\n    const t1 = scanner.tokens[scanner.pos];\n    const t2 = scanner.tokens[scanner.pos + 1];\n    return t1 && t2 && isLiteral(t1) && t2.type === 'Bracket';\n}\n\n/**\n * Parses given abbreviation into property set\n */\nfunction parse(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr, options && options.value) : abbr;\n        return parser(tokens, options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport { OperatorType, parse as default, getToken, parser, tokenize };\n//# sourceMappingURL=index.js.map\n",null,null,null,null,null,"{\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n}\n","{\n\t\"common\": [\"далеко-далеко\", \"за\", \"словесными\", \"горами\", \"в стране\", \"гласных\", \"и согласных\", \"живут\", \"рыбные\", \"тексты\"],\n\t\"words\": [\"вдали\", \"от всех\", \"они\", \"буквенных\", \"домах\", \"на берегу\", \"семантика\",\n\t\t\"большого\", \"языкового\", \"океана\", \"маленький\", \"ручеек\", \"даль\",\n\t\t\"журчит\", \"по всей\", \"обеспечивает\", \"ее\",\"всеми\", \"необходимыми\",\n\t\t\"правилами\", \"эта\", \"парадигматическая\", \"страна\", \"которой\", \"жаренные\",\n\t\t\"предложения\", \"залетают\", \"прямо\", \"рот\", \"даже\", \"всемогущая\",\n\t\t\"пунктуация\", \"не\", \"имеет\", \"власти\", \"над\", \"рыбными\", \"текстами\",\n\t\t\"ведущими\", \"безорфографичный\", \"образ\", \"жизни\", \"однажды\", \"одна\",\n\t\t\"маленькая\", \"строчка\",\"рыбного\", \"текста\", \"имени\", \"lorem\", \"ipsum\",\n\t\t\"решила\", \"выйти\", \"большой\", \"мир\", \"грамматики\", \"великий\", \"оксмокс\",\n\t\t\"предупреждал\", \"о\", \"злых\", \"запятых\", \"диких\", \"знаках\", \"вопроса\",\n\t\t\"коварных\", \"точках\", \"запятой\", \"но\", \"текст\", \"дал\", \"сбить\",\n\t\t\"себя\", \"толку\", \"он\", \"собрал\", \"семь\", \"своих\", \"заглавных\", \"букв\",\n\t\t\"подпоясал\", \"инициал\", \"за\", \"пояс\", \"пустился\", \"дорогу\",\n\t\t\"взобравшись\", \"первую\", \"вершину\", \"курсивных\", \"гор\", \"бросил\",\n\t\t\"последний\", \"взгляд\", \"назад\", \"силуэт\", \"своего\", \"родного\", \"города\",\n\t\t\"буквоград\", \"заголовок\", \"деревни\", \"алфавит\", \"подзаголовок\", \"своего\",\n\t\t\"переулка\", \"грустный\", \"реторический\", \"вопрос\", \"скатился\", \"его\",\n\t\t\"щеке\", \"продолжил\", \"свой\", \"путь\", \"дороге\", \"встретил\", \"рукопись\",\n\t\t\"она\", \"предупредила\",  \"моей\", \"все\", \"переписывается\", \"несколько\",\n\t\t\"раз\", \"единственное\", \"что\", \"меня\", \"осталось\", \"это\", \"приставка\",\n\t\t\"возвращайся\", \"ты\", \"лучше\", \"свою\", \"безопасную\", \"страну\", \"послушавшись\",\n\t\t\"рукописи\", \"наш\", \"продолжил\", \"свой\", \"путь\", \"вскоре\", \"ему\",\n\t\t\"повстречался\", \"коварный\", \"составитель\", \"рекламных\", \"текстов\",\n\t\t\"напоивший\", \"языком\", \"речью\", \"заманивший\", \"свое\", \"агентство\",\n\t\t\"которое\", \"использовало\", \"снова\", \"снова\", \"своих\", \"проектах\",\n\t\t\"если\", \"переписали\", \"то\", \"живет\", \"там\", \"до\", \"сих\", \"пор\"]\n}\n","{\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"más\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"paño\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"demás\", \"oficinista\", \"excepción\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"cuórum\", \"dignísimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedición\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"león\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"séquito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asunción\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentación\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindío\", \"pócima\",\n\t\t\"voluble\", \"débito\", \"sintió\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mínima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaña\", \"enigma\",\n\t\t\"total\", \"deletéreo\", \"décima\", \"cábala\", \"fotografía\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnífico\", \"distinción\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepúsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abadía\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almácigo\", \"vos\", \"pan\",\n\t\t\"represión\", \"números\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrón\", \"explícito\",\n\t\t\"paloma\", \"síndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apéndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propósito\",\n\t\t\"fantasía\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n}\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"{\n\t\"a\": \"a[href]\",\n\t\"a:blank\": \"a[href='http://${0}' target='_blank' rel='noopener noreferrer']\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:mf|link:manifest\": \"link[rel='manifest' href='${1:manifest.json}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"meta:refresh\": \"meta[http-equiv=refresh content='${1:5}']\",\n\t\"meta:kw\": \"meta[name=keywords content]\",\n\t\"meta:desc\": \"meta[name=description content]\",\n\t\"style\": \"style\",\n\t\"script\": \"script\",\n\t\"script:src\": \"script[src]\",\n\t\"script:module\": \"script[type=module src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:btn|input:button\": \"input[type=button value]\",\n\t\"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1}]\",\n\t\"tarea:c|textarea:cols\":\"textarea[name=${1} id=${1} cols=${2:30}]\",\n\t\"tarea:r|textarea:rows\":\"textarea[name=${1} id=${1} rows=${3:10}]\",\n\t\"tarea:cr|textarea:cols:rows\":\"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:b|button:b|button:button\" : \"button[type=button]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"sum\": \"summary\",\n\t\"cmd\": \"command\",\n\t\"data\": \"data[value]\",\n\t\"meter\": \"meter[value]\",\n\t\"time\": \"time[datetime]\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta:vp+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n}\n","{\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${2});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly\",\n\t\"ai\": \"align-items:start|end|flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:time\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:${1:#000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:${1:#000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:${1:#000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:${1:#000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:${1:#000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n  \"bbs\": \"border-block-start\",\n  \"bbe\": \"border-block-end\",\n  \"bis\": \"border-inline-start\",\n  \"bie\": \"border-inline-end\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:${1:#000}\",\n\t\"bg:n\": \"background: none\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:${1:#fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n  \"bs\": \"block-size\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:${1:#000}\",\n  \"cg\": \"column-gap\",\n\t\"cr\": \"color:rgb(${1:0}, ${2:0}, ${3:0})\",\n\t\"cra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, ${4:.5})\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters(${0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|grid|inline-grid|subgrid|list-item|run-in|contents|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fd\": \"font-display:auto|block|swap|fallback|optional\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fft\": \"font-family:\\\"Times New Roman\\\", Times, Baskerville, Georgia, serif\",\n\t\"ffa\": \"font-family:Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif\",\n\t\"ffv\": \"font-family:Verdana, Geneva, sans-serif\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fvs\": \"font-variation-settings:normal|inherit|initial|unset\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fsz\": \"font-size\",\n\t\"fsza\": \"font-size-adjust\",\n\t\"g\": \"gap\",\n\t\"gtc\": \"grid-template-columns:repeat(${0})|minmax()\",\n\t\"gtr\": \"grid-template-rows:repeat(${0})|minmax()\",\n\t\"gta\": \"grid-template-areas\",\n\t\"gt\": \"grid-template\",\n\t\"gg\": \"grid-gap\",\n\t\"gcg\": \"grid-column-gap\",\n\t\"grg\": \"grid-row-gap\",\n\t\"gac\": \"grid-auto-columns:auto|minmax()\",\n\t\"gar\": \"grid-auto-rows:auto|minmax()\",\n\t\"gaf\": \"grid-auto-flow:row|column|dense|inherit|initial|unset\",\n\t\"gd\": \"grid\",\n\t\"gc\": \"grid-column\",\n\t\"gcs\": \"grid-column-start\",\n\t\"gce\": \"grid-column-end\",\n\t\"gr\": \"grid-row\",\n\t\"grs\": \"grid-row-start\",\n\t\"gre\": \"grid-row-end\",\n\t\"ga\": \"grid-area\",\n\t\"h\": \"height\",\n  \"is\": \"inline-size\",\n\t\"jc\": \"justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly\",\n\t\"ji\": \"justify-items:start|end|center|stretch\",\n\t\"js\": \"justify-self:start|end|center|stretch\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n  \"mbs\": \"margin-block-start\",\n  \"mbe\": \"margin-block-end\",\n  \"mis\": \"margin-inline-start\",\n  \"mie\": \"margin-inline-end\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:${1:#000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width:thin|medium|thick\",\n\t\"op|opa\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n  \"pbs\": \"padding-block-start\",\n  \"pbe\": \"padding-block-end\",\n  \"pis\": \"padding-inline-start\",\n  \"pie\": \"padding-inline-end\",\n  \"spbs\": \"scroll-padding-block-start\",\n  \"spbe\": \"scroll-padding-block-end\",\n  \"spis\": \"scroll-padding-inline-start\",\n  \"spie\": \"scroll-padding-inline-end\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n  \"rg\": \"row-gap\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w|wid\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wido\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n}\n","{\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n}","{\n\t\"!!!\": \"{doctype html}\"\n}\n","{\n\t\"lang\": \"en\",\n\t\"locale\": \"en-US\",\n\t\"charset\": \"UTF-8\",\n\t\"indentation\": \"\\t\",\n\t\"newline\": \"\\n\"\n}\n",null,null,null,null,null,null,null],"names":["isNumber","isAlpha","isWhiteSpace","isQuote","tokenScanner","peek","readable","consume","error","element","isSiblingOperator","isBracket","isOperator","createLiteral","literal$1","isLiteral","Chars","tokenize","getToken","field","whiteSpace","literal","operator","bracket","isQuote$1","isOpenBracket","operatorType","consumePlaceholder","stringify","last","stringifyValue","isField","isCloseBracket","parse","walk","find","splitByLines","shouldFormat","abbreviation","snippets","attributes","calculateScore","defaultOptions","isAtHTMLTag","stringifyMarkup","parseMarkup","stringifyStylesheet","parseStylesheet"],"mappings":";;;;AAIA;AACA;AACA;AACA,SAASA,UAAQ,CAAC,IAAI,EAAE;AACxB,IAAI,OAAO,IAAI,GAAG,EAAE,IAAI,IAAI,GAAG,EAAE,CAAC;AAClC,CAAC;AACD;AACA;AACA;AACA,SAASC,SAAO,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE;AACjC,IAAI,IAAI,GAAG,IAAI,IAAI,EAAE,CAAC;AACtB,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC;AAClB,IAAI,IAAI,IAAI,CAAC,EAAE,CAAC;AAChB,IAAI,OAAO,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE,CAAC;AACtC,CAAC;AAOD,SAAS,kBAAkB,CAAC,IAAI,EAAE;AAClC,IAAI,OAAOD,UAAQ,CAAC,IAAI,CAAC,IAAI,WAAW,CAAC,IAAI,CAAC,CAAC;AAC/C,CAAC;AACD,SAAS,WAAW,CAAC,IAAI,EAAE;AAC3B,IAAI,OAAO,IAAI,KAAK,EAAE,YAAYC,SAAO,CAAC,IAAI,CAAC,CAAC;AAChD,CAAC;AACD;AACA;AACA;AACA,SAAS,QAAQ,CAAC,IAAI,EAAE;AACxB,IAAI,OAAO,IAAI,KAAK,GAAG;AACvB,WAAW,IAAI,IAAI,GAAG;AACtB,WAAW,IAAI,KAAK,GAAG;AACvB,WAAW,IAAI,KAAK,GAAG;AACvB,WAAW,IAAI,KAAK,GAAG;AACvB,WAAW,IAAI,KAAK,GAAG,CAAC;AACxB,CAAC;AACD;AACA;AACA;AACA;AACA,SAASC,cAAY,CAAC,IAAI,EAAE;AAC5B,IAAI,OAAO,IAAI,KAAK,EAAE;AACtB,WAAW,IAAI,KAAK,CAAC;AACrB,WAAW,IAAI,KAAK,GAAG,CAAC;AACxB,CAAC;AACD;AACA;AACA;AACA,SAAS,OAAO,CAAC,IAAI,EAAE;AACvB,IAAI,OAAOA,cAAY,CAAC,IAAI,CAAC;AAC7B,WAAW,IAAI,KAAK,EAAE;AACtB,WAAW,IAAI,KAAK,EAAE,CAAC;AACvB,CAAC;AA8BD;AACA;AACA;AACA,SAASC,SAAO,CAAC,IAAI,EAAE;AACvB,IAAI,OAAO,IAAI,KAAK,EAAE,YAAY,IAAI,KAAK,EAAE,SAAS;AACtD,CAAC;AAyCD;AACA;AACA;AACA;AACA,MAAM,OAAO,CAAC;AACd,IAAI,WAAW,CAAC,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE;AACjC,QAAQ,IAAI,GAAG,IAAI,IAAI,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;AACpD,YAAY,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC;AAC7B,SAAS;AACT,QAAQ,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC;AAC1B,QAAQ,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,GAAG,KAAK,IAAI,CAAC,CAAC;AAC3C,QAAQ,IAAI,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC,CAAC;AAC5B,KAAK;AACL;AACA;AACA;AACA,IAAI,GAAG,GAAG;AACV,QAAQ,OAAO,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC;AACpC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI,KAAK,CAAC,KAAK,EAAE,GAAG,EAAE;AACtB,QAAQ,OAAO,IAAI,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;AACpD,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,IAAI,GAAG;AACX,QAAQ,OAAO,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAChD,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,IAAI,GAAG;AACX,QAAQ,IAAI,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;AAC3C,YAAY,OAAO,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;AACtD,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,GAAG,CAAC,KAAK,EAAE;AACf,QAAQ,MAAM,EAAE,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;AAC/B,QAAQ,MAAM,EAAE,GAAG,OAAO,KAAK,KAAK,UAAU,GAAG,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE,KAAK,KAAK,CAAC;AAC1E,QAAQ,IAAI,EAAE,EAAE;AAChB,YAAY,IAAI,CAAC,IAAI,EAAE,CAAC;AACxB,SAAS;AACT,QAAQ,OAAO,EAAE,CAAC;AAClB,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,QAAQ,CAAC,KAAK,EAAE;AACpB,QAAQ,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC;AAC/B,QAAQ,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,SAAS;AACxD,QAAQ,OAAO,IAAI,CAAC,GAAG,KAAK,KAAK,CAAC;AAClC,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,MAAM,CAAC,CAAC,EAAE;AACd,QAAQ,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;AAC7B,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,OAAO,GAAG;AACd,QAAQ,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;AACpD,KAAK;AACL;AACA;AACA;AACA,IAAI,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE;AAC1B,QAAQ,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AAC7C,KAAK;AACL;AACA;AACA;AACA,IAAI,KAAK,CAAC,OAAO,EAAE,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE;AACnC,QAAQ,OAAO,IAAI,YAAY,CAAC,CAAC,EAAE,OAAO,CAAC,IAAI,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;AAC9E,KAAK;AACL,CAAC;AACD,MAAM,YAAY,SAAS,KAAK,CAAC;AACjC,IAAI,WAAW,CAAC,OAAO,EAAE,GAAG,EAAE,GAAG,EAAE;AACnC,QAAQ,KAAK,CAAC,OAAO,CAAC,CAAC;AACvB,QAAQ,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;AACvB,QAAQ,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC;AAC1B,KAAK;AACL;;ACvOA,SAASC,cAAY,CAAC,MAAM,EAAE;AAC9B,IAAI,OAAO;AACX,QAAQ,MAAM;AACd,QAAQ,KAAK,EAAE,CAAC;AAChB,QAAQ,GAAG,EAAE,CAAC;AACd,QAAQ,IAAI,EAAE,MAAM,CAAC,MAAM;AAC3B,KAAK,CAAC;AACN,CAAC;AACD,SAASC,MAAI,CAAC,OAAO,EAAE;AACvB,IAAI,OAAO,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;AACvC,CAAC;AACD,SAAS,IAAI,CAAC,OAAO,EAAE;AACvB,IAAI,OAAO,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC;AACzC,CAAC;AACD,SAAS,KAAK,CAAC,OAAO,EAAE,IAAI,GAAG,OAAO,CAAC,KAAK,EAAE,EAAE,GAAG,OAAO,CAAC,GAAG,EAAE;AAChE,IAAI,OAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;AAC1C,CAAC;AACD,SAASC,UAAQ,CAAC,OAAO,EAAE;AAC3B,IAAI,OAAO,OAAO,CAAC,GAAG,GAAG,OAAO,CAAC,IAAI,CAAC;AACtC,CAAC;AACD,SAASC,SAAO,CAAC,OAAO,EAAE,IAAI,EAAE;AAChC,IAAI,MAAM,KAAK,GAAGF,MAAI,CAAC,OAAO,CAAC,CAAC;AAChC,IAAI,IAAI,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE;AAC9B,QAAQ,OAAO,CAAC,GAAG,EAAE,CAAC;AACtB,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC;AACD,SAASG,OAAK,CAAC,OAAO,EAAE,OAAO,EAAE,KAAK,GAAGH,MAAI,CAAC,OAAO,CAAC,EAAE;AACxD,IAAI,IAAI,KAAK,IAAI,KAAK,CAAC,KAAK,IAAI,IAAI,EAAE;AACtC,QAAQ,OAAO,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;AACxC,KAAK;AACL,IAAI,MAAM,GAAG,GAAG,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC;AACnC,IAAI,GAAG,CAAC,KAAK,CAAC,GAAG,KAAK,IAAI,KAAK,CAAC,KAAK,CAAC;AACtC,IAAI,OAAO,GAAG,CAAC;AACf,CAAC;AACD;AACA,SAAS,YAAY,CAAC,IAAI,EAAE,OAAO,GAAG,EAAE,EAAE;AAC1C,IAAI,MAAM,OAAO,GAAGD,cAAY,CAAC,IAAI,CAAC,CAAC;AACvC,IAAI,MAAM,MAAM,GAAG,UAAU,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;AAChD,IAAI,IAAIE,UAAQ,CAAC,OAAO,CAAC,EAAE;AAC3B,QAAQ,MAAME,OAAK,CAAC,OAAO,EAAE,sBAAsB,CAAC,CAAC;AACrD,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD,SAAS,UAAU,CAAC,OAAO,EAAE,OAAO,EAAE;AACtC,IAAI,MAAM,MAAM,GAAG;AACnB,QAAQ,IAAI,EAAE,YAAY;AAC1B,QAAQ,QAAQ,EAAE,EAAE;AACpB,KAAK,CAAC;AACN,IAAI,IAAI,GAAG,GAAG,MAAM,CAAC;AACrB,IAAI,IAAI,IAAI,CAAC;AACb,IAAI,MAAM,KAAK,GAAG,EAAE,CAAC;AACrB,IAAI,OAAOF,UAAQ,CAAC,OAAO,CAAC,EAAE;AAC9B,QAAQ,IAAI,IAAI,GAAGG,SAAO,CAAC,OAAO,EAAE,OAAO,CAAC,IAAI,KAAK,CAAC,OAAO,EAAE,OAAO,CAAC,EAAE;AACzE,YAAY,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACpC,YAAY,IAAIF,SAAO,CAAC,OAAO,EAAE,eAAe,CAAC,EAAE;AACnD,gBAAgB,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAChC,gBAAgB,GAAG,GAAG,IAAI,CAAC;AAC3B,aAAa;AACb,iBAAiB,IAAIA,SAAO,CAAC,OAAO,EAAEG,mBAAiB,CAAC,EAAE;AAC1D,gBAAgB,SAAS;AACzB,aAAa;AACb,iBAAiB,IAAIH,SAAO,CAAC,OAAO,EAAE,eAAe,CAAC,EAAE;AACxD,gBAAgB,GAAG;AACnB,oBAAoB,IAAI,KAAK,CAAC,MAAM,EAAE;AACtC,wBAAwB,GAAG,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;AAC1C,qBAAqB;AACrB,iBAAiB,QAAQA,SAAO,CAAC,OAAO,EAAE,eAAe,CAAC,EAAE;AAC5D,aAAa;AACb,SAAS;AACT,aAAa;AACb,YAAY,MAAM;AAClB,SAAS;AACT,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD;AACA;AACA;AACA,SAAS,KAAK,CAAC,OAAO,EAAE,OAAO,EAAE;AACjC,IAAI,IAAIA,SAAO,CAAC,OAAO,EAAE,YAAY,CAAC,EAAE;AACxC,QAAQ,MAAM,MAAM,GAAG,UAAU,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;AACpD,QAAQ,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC;AACpC,QAAQ,IAAII,WAAS,CAAC,KAAK,EAAE,OAAO,EAAE,KAAK,CAAC,EAAE;AAC9C,YAAY,MAAM,CAAC,MAAM,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;AAChD,SAAS;AACT,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA,SAASF,SAAO,CAAC,OAAO,EAAE,OAAO,EAAE;AACnC,IAAI,IAAI,IAAI,CAAC;AACb,IAAI,MAAM,IAAI,GAAG;AACjB,QAAQ,IAAI,EAAE,cAAc;AAC5B,QAAQ,IAAI,EAAE,KAAK,CAAC;AACpB,QAAQ,UAAU,EAAE,KAAK,CAAC;AAC1B,QAAQ,KAAK,EAAE,KAAK,CAAC;AACrB,QAAQ,MAAM,EAAE,KAAK,CAAC;AACtB,QAAQ,SAAS,EAAE,KAAK;AACxB,QAAQ,QAAQ,EAAE,EAAE;AACpB,KAAK,CAAC;AACN,IAAI,IAAI,WAAW,CAAC,OAAO,EAAE,OAAO,CAAC,EAAE;AACvC,QAAQ,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC;AACnC,KAAK;AACL,IAAI,OAAOH,UAAQ,CAAC,OAAO,CAAC,EAAE;AAC9B,QAAQ,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AACpC,QAAQ,IAAI,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAIC,SAAO,CAAC,OAAO,EAAE,UAAU,CAAC,EAAE;AAC5E,YAAY,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC1D,SAAS;AACT,aAAa,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,OAAO,CAAC,EAAE;AAC/C,YAAY,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;AAC1C,SAAS;AACT,aAAa,IAAI,IAAI,GAAG,cAAc,CAAC,OAAO,EAAE,IAAI,EAAE,OAAO,CAAC,IAAI,cAAc,CAAC,OAAO,EAAE,OAAO,EAAE,OAAO,CAAC,IAAI,YAAY,CAAC,OAAO,CAAC,EAAE;AACtI,YAAY,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;AAClC,gBAAgB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;AAC9E,aAAa;AACb,iBAAiB;AACjB,gBAAgB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AAC/D,aAAa;AACb,SAAS;AACT,aAAa;AACb,YAAY,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAIA,SAAO,CAAC,OAAO,EAAE,eAAe,CAAC,EAAE;AACrE,gBAAgB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;AACtC,gBAAgB,IAAI,CAAC,IAAI,CAAC,MAAM,IAAIA,SAAO,CAAC,OAAO,EAAE,UAAU,CAAC,EAAE;AAClE,oBAAoB,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAClE,iBAAiB;AACjB,aAAa;AACb,YAAY,MAAM;AAClB,SAAS;AACT,KAAK;AACL,IAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,KAAK,CAAC,CAAC;AAC1C,CAAC;AACD;AACA;AACA;AACA,SAAS,YAAY,CAAC,OAAO,EAAE;AAC/B,IAAI,IAAIA,SAAO,CAAC,OAAO,EAAE,mBAAmB,CAAC,EAAE;AAC/C,QAAQ,MAAM,UAAU,GAAG,EAAE,CAAC;AAC9B,QAAQ,IAAI,IAAI,CAAC;AACjB,QAAQ,OAAOD,UAAQ,CAAC,OAAO,CAAC,EAAE;AAClC,YAAY,IAAI,IAAI,GAAG,SAAS,CAAC,OAAO,CAAC,EAAE;AAC3C,gBAAgB,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACtC,aAAa;AACb,iBAAiB,IAAIC,SAAO,CAAC,OAAO,EAAE,iBAAiB,CAAC,EAAE;AAC1D,gBAAgB,MAAM;AACtB,aAAa;AACb,iBAAiB,IAAI,CAACA,SAAO,CAAC,OAAO,EAAEL,cAAY,CAAC,EAAE;AACtD,gBAAgB,MAAMM,OAAK,CAAC,OAAO,EAAE,CAAC,YAAY,EAAEH,MAAI,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;AACjF,aAAa;AACb,SAAS;AACT,QAAQ,OAAO,UAAU,CAAC;AAC1B,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA,SAAS,cAAc,CAAC,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE;AAChD,IAAI,IAAIO,YAAU,CAACP,MAAI,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,EAAE;AACzC,QAAQ,OAAO,CAAC,GAAG,EAAE,CAAC;AACtB;AACA,QAAQ,IAAI,KAAK,GAAG,CAAC,CAAC;AACtB,QAAQ,OAAOO,YAAU,CAACP,MAAI,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,EAAE;AAChD,YAAY,OAAO,CAAC,GAAG,EAAE,CAAC;AAC1B,YAAY,KAAK,EAAE,CAAC;AACpB,SAAS;AACT,QAAQ,MAAM,IAAI,GAAG;AACrB,YAAY,IAAI,EAAE,CAACQ,eAAa,CAAC,IAAI,CAAC,CAAC;AACvC,SAAS,CAAC;AACV,QAAQ,IAAI,KAAK,GAAG,CAAC,EAAE;AACvB,YAAY,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;AACjC,SAAS;AACT;AACA,QAAQ,IAAI,OAAO,CAAC,GAAG,IAAI,IAAI,CAAC,OAAO,CAAC,EAAE;AAC1C,YAAY,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;AAC1C,YAAY,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;AACnC,SAAS;AACT,aAAa;AACb,YAAY,IAAI,CAAC,KAAK,GAAGC,WAAS,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC,CAAC;AACtE,SAAS;AACT,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA,SAAS,SAAS,CAAC,OAAO,EAAE;AAC5B,IAAI,IAAI,MAAM,CAAC,OAAO,CAAC,EAAE;AACzB;AACA,QAAQ,OAAO;AACf,YAAY,KAAK,EAAE,KAAK,CAAC,OAAO,CAAC;AACjC,SAAS,CAAC;AACV,KAAK;AACL,IAAI,IAAIA,WAAS,CAAC,OAAO,EAAE,IAAI,CAAC,EAAE;AAClC,QAAQ,MAAM,IAAI,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC;AACpC,QAAQ,IAAI,KAAK,CAAC;AAClB,QAAQ,IAAIP,SAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,EAAE;AACxC,YAAY,IAAI,MAAM,CAAC,OAAO,CAAC,IAAIO,WAAS,CAAC,OAAO,EAAE,IAAI,CAAC,EAAE;AAC7D,gBAAgB,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC;AACvC,aAAa;AACb,SAAS;AACT,QAAQ,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC;AAC/B,KAAK;AACL,CAAC;AACD,SAAS,UAAU,CAAC,OAAO,EAAE;AAC7B,IAAI,OAAO,UAAU,CAACT,MAAI,CAAC,OAAO,CAAC,CAAC;AACpC,UAAU,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;AACvC,UAAU,KAAK,CAAC,CAAC;AACjB,CAAC;AACD;AACA;AACA;AACA,SAAS,MAAM,CAAC,OAAO,EAAE;AACzB,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AAC9B,IAAI,MAAM,KAAK,GAAGA,MAAI,CAAC,OAAO,CAAC,CAAC;AAChC,IAAI,IAAIF,SAAO,CAAC,KAAK,CAAC,EAAE;AACxB,QAAQ,OAAO,CAAC,GAAG,EAAE,CAAC;AACtB,QAAQ,OAAOG,UAAQ,CAAC,OAAO,CAAC,EAAE;AAClC,YAAY,IAAIH,SAAO,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,EAAE;AACtD,gBAAgB,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;AACtC,gBAAgB,OAAO,IAAI,CAAC;AAC5B,aAAa;AACb,SAAS;AACT,QAAQ,MAAMK,OAAK,CAAC,OAAO,EAAE,gBAAgB,EAAE,KAAK,CAAC,CAAC;AACtD,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC;AACD;AACA;AACA;AACA,SAASM,WAAS,CAAC,OAAO,EAAE,aAAa,EAAE;AAC3C,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AAC9B,IAAI,MAAM,QAAQ,GAAG;AACrB,QAAQ,SAAS,EAAE,CAAC;AACpB,QAAQ,UAAU,EAAE,CAAC;AACrB,QAAQ,KAAK,EAAE,CAAC;AAChB,KAAK,CAAC;AACN,IAAI,OAAOR,UAAQ,CAAC,OAAO,CAAC,EAAE;AAC9B,QAAQ,MAAM,KAAK,GAAGD,MAAI,CAAC,OAAO,CAAC,CAAC;AACpC,QAAQ,IAAI,QAAQ,CAAC,UAAU,EAAE;AACjC;AACA,YAAY,IAAIM,WAAS,CAAC,KAAK,EAAE,YAAY,CAAC,EAAE;AAChD,gBAAgB,QAAQ,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,KAAK,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAC/D,aAAa;AACb,SAAS;AACT,aAAa,IAAIR,SAAO,CAAC,KAAK,CAAC,IAAIS,YAAU,CAAC,KAAK,CAAC,IAAIV,cAAY,CAAC,KAAK,CAAC,IAAI,UAAU,CAAC,KAAK,CAAC,EAAE;AAClG,YAAY,MAAM;AAClB,SAAS;AACT,aAAa,IAAIS,WAAS,CAAC,KAAK,CAAC,EAAE;AACnC,YAAY,IAAI,CAAC,aAAa,EAAE;AAChC,gBAAgB,MAAM;AACtB,aAAa;AACb,YAAY,IAAI,KAAK,CAAC,IAAI,EAAE;AAC5B,gBAAgB,QAAQ,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC;AAC1C,aAAa;AACb,iBAAiB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE;AAC/C;AACA;AACA,gBAAgB,MAAM;AACtB,aAAa;AACb,iBAAiB;AACjB,gBAAgB,QAAQ,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC;AAC1C,aAAa;AACb,SAAS;AACT,QAAQ,OAAO,CAAC,GAAG,EAAE,CAAC;AACtB,KAAK;AACL,IAAI,IAAI,KAAK,KAAK,OAAO,CAAC,GAAG,EAAE;AAC/B,QAAQ,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;AAC9B,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC;AACD;AACA;AACA;AACA,SAAS,WAAW,CAAC,OAAO,EAAE,OAAO,EAAE;AACvC,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AAC9B,IAAI,IAAI,OAAO,CAAC,GAAG,IAAIJ,SAAO,CAAC,OAAO,EAAE,oBAAoB,CAAC,EAAE;AAC/D;AACA;AACA,QAAQ,OAAOD,UAAQ,CAAC,OAAO,CAAC,EAAE;AAClC,YAAY,MAAM,EAAE,GAAG,EAAE,GAAG,OAAO,CAAC;AACpC,YAAY,IAAI,CAACC,SAAO,CAAC,OAAO,EAAE,mBAAmB,CAAC,IAAI,CAACA,SAAO,CAAC,OAAO,EAAE,oBAAoB,CAAC,EAAE;AACnG,gBAAgB,OAAO,CAAC,GAAG,GAAG,GAAG,CAAC;AAClC,gBAAgB,MAAM;AACtB,aAAa;AACb,SAAS;AACT,KAAK;AACL,IAAI,OAAOD,UAAQ,CAAC,OAAO,CAAC,IAAIC,SAAO,CAAC,OAAO,EAAE,eAAe,CAAC,EAAE;AACnE;AACA,KAAK;AACL,IAAI,IAAI,OAAO,CAAC,GAAG,KAAK,KAAK,EAAE;AAC/B,QAAQ,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;AAC9B,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC;AACD;AACA;AACA;AACA,SAAS,IAAI,CAAC,OAAO,EAAE;AACvB,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AAC9B,IAAI,IAAIA,SAAO,CAAC,OAAO,EAAE,WAAW,CAAC,EAAE;AACvC,QAAQ,IAAI,QAAQ,GAAG,CAAC,CAAC;AACzB,QAAQ,OAAOD,UAAQ,CAAC,OAAO,CAAC,EAAE;AAClC,YAAY,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC;AACxC,YAAY,IAAIK,WAAS,CAAC,KAAK,EAAE,YAAY,CAAC,EAAE;AAChD,gBAAgB,IAAI,KAAK,CAAC,IAAI,EAAE;AAChC,oBAAoB,QAAQ,EAAE,CAAC;AAC/B,iBAAiB;AACjB,qBAAqB,IAAI,CAAC,QAAQ,EAAE;AACpC,oBAAoB,MAAM;AAC1B,iBAAiB;AACjB,qBAAqB;AACrB,oBAAoB,QAAQ,EAAE,CAAC;AAC/B,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,QAAQ,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;AAC9B,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC;AACD,SAAS,OAAO,CAAC,OAAO,EAAE;AAC1B,IAAI,IAAI,IAAI,GAAG,OAAO,CAAC,KAAK,CAAC;AAC7B,IAAI,IAAI,EAAE,GAAG,OAAO,CAAC,GAAG,CAAC;AACzB,IAAI,IAAIA,WAAS,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,YAAY,EAAE,IAAI,CAAC,EAAE;AAC7D,QAAQ,IAAI,EAAE,CAAC;AACf,KAAK;AACL,IAAI,IAAIA,WAAS,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,YAAY,EAAE,KAAK,CAAC,EAAE;AAChE,QAAQ,EAAE,EAAE,CAAC;AACb,KAAK;AACL,IAAI,OAAO,KAAK,CAAC,OAAO,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC;AACpC,CAAC;AACD,SAASA,WAAS,CAAC,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS;AACpD,YAAY,CAAC,OAAO,IAAI,KAAK,CAAC,OAAO,KAAK,OAAO,CAAC;AAClD,YAAY,MAAM,IAAI,IAAI,IAAI,KAAK,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC,CAAC;AACtD,CAAC;AACD,SAASC,YAAU,CAAC,KAAK,EAAE,IAAI,EAAE;AACjC,IAAI,OAAO,OAAO,CAAC,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,UAAU,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,QAAQ,KAAK,IAAI,CAAC,CAAC,CAAC;AAC7F,CAAC;AACD,SAAST,SAAO,CAAC,KAAK,EAAE,QAAQ,EAAE;AAClC,IAAI,OAAO,OAAO,CAAC,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,OAAO,KAAK,QAAQ,IAAI,IAAI,IAAI,KAAK,CAAC,MAAM,KAAK,QAAQ,CAAC,CAAC,CAAC;AACvG,CAAC;AACD,SAASD,cAAY,CAAC,KAAK,EAAE;AAC7B,IAAI,OAAO,OAAO,CAAC,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,YAAY,CAAC,CAAC;AACzD,CAAC;AACD,SAAS,QAAQ,CAAC,KAAK,EAAE;AACzB,IAAI,OAAOU,YAAU,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;AACtC,CAAC;AACD,SAAS,UAAU,CAAC,KAAK,EAAE;AAC3B,IAAI,OAAO,OAAO,CAAC,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,UAAU,CAAC,CAAC;AACvD,CAAC;AACD,SAASG,WAAS,CAAC,KAAK,EAAE;AAC1B,IAAI,OAAO,KAAK,CAAC,IAAI,KAAK,SAAS,CAAC;AACpC,CAAC;AACD,SAAS,oBAAoB,CAAC,KAAK,EAAE;AACrC,IAAI,IAAIA,WAAS,CAAC,KAAK,CAAC,EAAE;AAC1B,QAAQ,MAAM,EAAE,GAAG,KAAK,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAC7C,QAAQ,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;AACpC,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC;AACD,SAAS,eAAe,CAAC,KAAK,EAAE;AAChC,IAAI,OAAO,KAAK,CAAC,IAAI,KAAK,SAAS,IAAI,KAAK,CAAC,IAAI,KAAK,gBAAgB,IAAI,KAAK,CAAC,IAAI,KAAK,qBAAqB,CAAC;AAC/G,CAAC;AACD,SAAS,mBAAmB,CAAC,KAAK,EAAE;AACpC,IAAI,OAAOH,YAAU,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;AACtC,CAAC;AACD,SAAS,mBAAmB,CAAC,KAAK,EAAE;AACpC,IAAI,OAAOD,WAAS,CAAC,KAAK,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC;AAC/C,CAAC;AACD,SAAS,iBAAiB,CAAC,KAAK,EAAE;AAClC,IAAI,OAAOA,WAAS,CAAC,KAAK,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC;AAChD,CAAC;AACD,SAAS,WAAW,CAAC,KAAK,EAAE;AAC5B,IAAI,OAAOA,WAAS,CAAC,KAAK,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;AAChD,CAAC;AACD,SAAS,YAAY,CAAC,KAAK,EAAE;AAC7B,IAAI,OAAOA,WAAS,CAAC,KAAK,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;AAC3C,CAAC;AACD,SAASE,eAAa,CAAC,KAAK,EAAE;AAC9B,IAAI,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC;AACtC,CAAC;AACD,SAAS,OAAO,CAAC,IAAI,EAAE;AACvB,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC;AACzD,CAAC;AACD,SAAS,eAAe,CAAC,KAAK,EAAE;AAChC,IAAI,OAAOD,YAAU,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;AACtC,CAAC;AACD,SAASF,mBAAiB,CAAC,KAAK,EAAE;AAClC,IAAI,OAAOE,YAAU,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;AACxC,CAAC;AACD,SAAS,eAAe,CAAC,KAAK,EAAE;AAChC,IAAI,OAAOA,YAAU,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;AACtC,CAAC;AACD,SAAS,eAAe,CAAC,KAAK,EAAE;AAChC,IAAI,OAAOA,YAAU,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;AACtC,CAAC;AACD;AACA,IAAII,OAAK,CAAC;AACV,CAAC,UAAU,KAAK,EAAE;AAClB;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,kBAAkB,CAAC,GAAG,GAAG,CAAC,GAAG,kBAAkB,CAAC;AAChE;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,mBAAmB,CAAC,GAAG,GAAG,CAAC,GAAG,mBAAmB,CAAC;AAClE;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,GAAG,QAAQ,CAAC;AAC3C;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,GAAG,QAAQ,CAAC;AAC3C;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,mBAAmB,CAAC,GAAG,EAAE,CAAC,GAAG,mBAAmB,CAAC;AACjE;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,oBAAoB,CAAC,GAAG,EAAE,CAAC,GAAG,oBAAoB,CAAC;AACnE;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,UAAU,CAAC;AAC/C;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,MAAM,CAAC;AACvC;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,GAAG,QAAQ,CAAC;AAC3C;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,MAAM,CAAC;AACvC;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,GAAG,KAAK,CAAC;AACrC;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,GAAG,OAAO,CAAC;AACzC;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,GAAG,OAAO,CAAC;AACzC;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,MAAM,CAAC;AACvC;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC;AACnC;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,GAAG,YAAY,CAAC;AACnD;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,kBAAkB,CAAC,GAAG,EAAE,CAAC,GAAG,kBAAkB,CAAC;AAC/D;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,mBAAmB,CAAC,GAAG,EAAE,CAAC,GAAG,mBAAmB,CAAC;AACjE;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS,CAAC;AAC7C;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,GAAG,OAAO,CAAC;AACzC;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,GAAG,OAAO,CAAC;AACzC;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,GAAG,aAAa,CAAC;AACrD;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,GAAG,aAAa,CAAC;AACrD,CAAC,EAAEA,OAAK,KAAKA,OAAK,GAAG,EAAE,CAAC,CAAC,CAAC;AAC1B;AACA;AACA;AACA,SAAS,OAAO,CAAC,OAAO,EAAE;AAC1B,IAAI,IAAI,OAAO,CAAC,GAAG,CAACA,OAAK,CAAC,MAAM,CAAC,EAAE;AACnC,QAAQ,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AACpC,QAAQ,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE;AAC5B,YAAY,OAAO,CAAC,GAAG,EAAE,CAAC;AAC1B,SAAS;AACT,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC;AACD;AACA,SAASC,UAAQ,CAAC,MAAM,EAAE;AAC1B,IAAI,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC;AACxC,IAAI,MAAM,MAAM,GAAG,EAAE,CAAC;AACtB,IAAI,MAAM,GAAG,GAAG;AAChB,QAAQ,KAAK,EAAE,CAAC;AAChB,QAAQ,SAAS,EAAE,CAAC;AACpB,QAAQ,UAAU,EAAE,CAAC;AACrB,QAAQ,KAAK,EAAE,CAAC;AAChB,KAAK,CAAC;AACN,IAAI,IAAI,EAAE,GAAG,CAAC,CAAC;AACf,IAAI,IAAI,KAAK,CAAC;AACd,IAAI,OAAO,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE;AAC3B,QAAQ,EAAE,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC;AAC5B,QAAQ,KAAK,GAAGC,UAAQ,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;AACvC,QAAQ,IAAI,KAAK,EAAE;AACnB,YAAY,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC/B,YAAY,IAAI,KAAK,CAAC,IAAI,KAAK,OAAO,EAAE;AACxC,gBAAgB,GAAG,CAAC,KAAK,GAAG,EAAE,KAAK,GAAG,CAAC,KAAK,GAAG,CAAC,GAAG,EAAE,CAAC;AACtD,aAAa;AACb,iBAAiB,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE;AAC/C,gBAAgB,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,KAAK,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAC1D,aAAa;AACb,SAAS;AACT,aAAa;AACb,YAAY,MAAM,OAAO,CAAC,KAAK,CAAC,sBAAsB,CAAC,CAAC;AACxD,SAAS;AACT,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD;AACA;AACA;AACA,SAASA,UAAQ,CAAC,OAAO,EAAE,GAAG,EAAE;AAChC,IAAI,OAAOC,OAAK,CAAC,OAAO,EAAE,GAAG,CAAC;AAC9B,WAAW,mBAAmB,CAAC,OAAO,CAAC;AACvC,WAAW,cAAc,CAAC,OAAO,CAAC;AAClC,WAAW,QAAQ,CAAC,OAAO,CAAC;AAC5B,WAAWC,YAAU,CAAC,OAAO,CAAC;AAC9B,WAAWC,SAAO,CAAC,OAAO,EAAE,GAAG,CAAC;AAChC,WAAWC,UAAQ,CAAC,OAAO,CAAC;AAC5B,WAAW,KAAK,CAAC,OAAO,CAAC;AACzB,WAAWC,SAAO,CAAC,OAAO,CAAC,CAAC;AAC5B,CAAC;AACD;AACA;AACA;AACA,SAASF,SAAO,CAAC,OAAO,EAAE,GAAG,EAAE;AAC/B,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AAC9B,IAAI,MAAM,eAAe,GAAG,GAAG,CAAC,UAAU,CAAC;AAC3C,IAAI,IAAI,KAAK,GAAG,EAAE,CAAC;AACnB,IAAI,OAAO,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE;AAC3B;AACA,QAAQ,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;AAC9B,YAAY,KAAK,IAAI,OAAO,CAAC,OAAO,EAAE,CAAC;AACvC,YAAY,SAAS;AACrB,SAAS;AACT,QAAQ,MAAM,EAAE,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC;AAClC,QAAQ,IAAI,EAAE,KAAKL,OAAK,CAAC,KAAK,IAAI,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC,GAAG,CAAC,UAAU,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE;AACnF;AACA,YAAY,MAAM,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AACpE,YAAY,MAAM,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AACpE,YAAY,IAAIhB,UAAQ,CAAC,IAAI,CAAC,IAAIA,UAAQ,CAAC,IAAI,CAAC,EAAE;AAClD,gBAAgB,KAAK,IAAI,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC;AACvD,gBAAgB,SAAS;AACzB,aAAa;AACb,SAAS;AACT,QAAQ,IAAI,EAAE,KAAK,GAAG,CAAC,KAAK,IAAI,EAAE,KAAKgB,OAAK,CAAC,MAAM,IAAI,iBAAiB,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE;AACnF;AACA;AACA;AACA,YAAY,MAAM;AAClB,SAAS;AACT,QAAQ,IAAI,eAAe,EAAE;AAC7B;AACA,YAAY,IAAI,EAAE,KAAKA,OAAK,CAAC,gBAAgB,EAAE;AAC/C,gBAAgB,GAAG,CAAC,UAAU,EAAE,CAAC;AACjC,aAAa;AACb,iBAAiB,IAAI,EAAE,KAAKA,OAAK,CAAC,iBAAiB,EAAE;AACrD,gBAAgB,IAAI,GAAG,CAAC,UAAU,GAAG,eAAe,EAAE;AACtD,oBAAoB,GAAG,CAAC,UAAU,EAAE,CAAC;AACrC,iBAAiB;AACjB,qBAAqB;AACrB,oBAAoB,MAAM;AAC1B,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,aAAa,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE;AAC7B;AACA,YAAY,IAAI,CAAC,GAAG,CAAC,SAAS,IAAI,CAAC,aAAa,CAAC,EAAE,CAAC,EAAE;AACtD,gBAAgB,MAAM;AACtB,aAAa;AACb,YAAY,IAAI,cAAc,CAAC,EAAE,EAAE,GAAG,CAAC,IAAI,iBAAiB,CAAC,EAAE,EAAE,GAAG,CAAC,IAAIQ,SAAS,CAAC,EAAE,CAAC,IAAI,WAAW,CAAC,EAAE,CAAC,EAAE;AAC3G;AACA,gBAAgB,MAAM;AACtB,aAAa;AACb,SAAS;AACT,QAAQ,KAAK,IAAI,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC;AAC/C,KAAK;AACL,IAAI,IAAI,KAAK,KAAK,OAAO,CAAC,GAAG,EAAE;AAC/B,QAAQ,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;AAC9B,QAAQ,OAAO;AACf,YAAY,IAAI,EAAE,SAAS;AAC3B,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY,GAAG,EAAE,OAAO,CAAC,GAAG;AAC5B,SAAS,CAAC;AACV,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA,SAASJ,YAAU,CAAC,OAAO,EAAE;AAC7B,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AAC9B,IAAI,IAAI,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;AACnC,QAAQ,OAAO;AACf,YAAY,IAAI,EAAE,YAAY;AAC9B,YAAY,KAAK;AACjB,YAAY,GAAG,EAAE,OAAO,CAAC,GAAG;AAC5B,YAAY,KAAK,EAAE,OAAO,CAAC,SAAS,CAAC,KAAK,EAAE,OAAO,CAAC,GAAG,CAAC;AACxD,SAAS,CAAC;AACV,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA,SAAS,KAAK,CAAC,OAAO,EAAE;AACxB,IAAI,MAAM,EAAE,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC;AAC9B,IAAI,IAAII,SAAS,CAAC,EAAE,CAAC,EAAE;AACvB,QAAQ,OAAO;AACf,YAAY,IAAI,EAAE,OAAO;AACzB,YAAY,MAAM,EAAE,EAAE,KAAKR,OAAK,CAAC,WAAW;AAC5C,YAAY,KAAK,EAAE,OAAO,CAAC,GAAG,EAAE;AAChC,YAAY,GAAG,EAAE,OAAO,CAAC,GAAG;AAC5B,SAAS,CAAC;AACV,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA,SAASO,SAAO,CAAC,OAAO,EAAE;AAC1B,IAAI,MAAM,EAAE,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC;AAC9B,IAAI,MAAM,OAAO,GAAG,WAAW,CAAC,EAAE,CAAC,CAAC;AACpC,IAAI,IAAI,OAAO,EAAE;AACjB,QAAQ,OAAO;AACf,YAAY,IAAI,EAAE,SAAS;AAC3B,YAAY,IAAI,EAAEE,eAAa,CAAC,EAAE,CAAC;AACnC,YAAY,OAAO;AACnB,YAAY,KAAK,EAAE,OAAO,CAAC,GAAG,EAAE;AAChC,YAAY,GAAG,EAAE,OAAO,CAAC,GAAG;AAC5B,SAAS,CAAC;AACV,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA,SAASH,UAAQ,CAAC,OAAO,EAAE;AAC3B,IAAI,MAAM,EAAE,GAAGI,cAAY,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC;AAC5C,IAAI,IAAI,EAAE,EAAE;AACZ,QAAQ,OAAO;AACf,YAAY,IAAI,EAAE,UAAU;AAC5B,YAAY,QAAQ,EAAE,EAAE;AACxB,YAAY,KAAK,EAAE,OAAO,CAAC,GAAG,EAAE;AAChC,YAAY,GAAG,EAAE,OAAO,CAAC,GAAG;AAC5B,SAAS,CAAC;AACV,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA,SAAS,QAAQ,CAAC,OAAO,EAAE;AAC3B,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AAC9B,IAAI,IAAI,OAAO,CAAC,GAAG,CAACV,OAAK,CAAC,QAAQ,CAAC,EAAE;AACrC,QAAQ,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AACpC,QAAQ,IAAI,KAAK,GAAG,CAAC,CAAC;AACtB,QAAQ,IAAI,QAAQ,GAAG,KAAK,CAAC;AAC7B,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAChB,UAAQ,CAAC,EAAE;AACxC,YAAY,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;AAC9C,SAAS;AACT,aAAa;AACb,YAAY,QAAQ,GAAG,IAAI,CAAC;AAC5B,SAAS;AACT,QAAQ,OAAO;AACf,YAAY,IAAI,EAAE,UAAU;AAC5B,YAAY,KAAK;AACjB,YAAY,KAAK,EAAE,CAAC;AACpB,YAAY,QAAQ;AACpB,YAAY,KAAK;AACjB,YAAY,GAAG,EAAE,OAAO,CAAC,GAAG;AAC5B,SAAS,CAAC;AACV,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA,SAAS,mBAAmB,CAAC,OAAO,EAAE;AACtC,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AAC9B,IAAI,IAAI,OAAO,CAAC,GAAG,CAACgB,OAAK,CAAC,MAAM,CAAC,IAAI,OAAO,CAAC,GAAG,CAACA,OAAK,CAAC,IAAI,CAAC,EAAE;AAC9D,QAAQ,OAAO;AACf,YAAY,IAAI,EAAE,qBAAqB;AACvC,YAAY,KAAK,EAAE,KAAK,CAAC;AACzB,YAAY,KAAK;AACjB,YAAY,GAAG,EAAE,OAAO,CAAC,GAAG;AAC5B,SAAS,CAAC;AACV,KAAK;AACL,IAAI,OAAO,CAAC,GAAG,GAAG,KAAK,CAAC;AACxB,CAAC;AACD;AACA;AACA;AACA,SAAS,cAAc,CAAC,OAAO,EAAE;AACjC,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AAC9B,IAAI,IAAI,OAAO,CAAC,QAAQ,CAACA,OAAK,CAAC,MAAM,CAAC,EAAE;AACxC,QAAQ,MAAM,IAAI,GAAG,OAAO,CAAC,GAAG,GAAG,KAAK,CAAC;AACzC,QAAQ,IAAI,OAAO,GAAG,KAAK,CAAC;AAC5B,QAAQ,IAAI,IAAI,GAAG,CAAC,CAAC;AACrB,QAAQ,IAAI,MAAM,GAAG,CAAC,CAAC;AACvB,QAAQ,IAAI,OAAO,CAAC,GAAG,CAACA,OAAK,CAAC,EAAE,CAAC,EAAE;AACnC;AACA,YAAY,OAAO,OAAO,CAAC,GAAG,CAACA,OAAK,CAAC,KAAK,CAAC,EAAE;AAC7C,gBAAgB,MAAM,EAAE,CAAC;AACzB,aAAa;AACb,YAAY,OAAO,GAAG,OAAO,CAAC,GAAG,CAACA,OAAK,CAAC,IAAI,CAAC,CAAC;AAC9C,YAAY,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AACxC,YAAY,IAAI,OAAO,CAAC,QAAQ,CAAChB,UAAQ,CAAC,EAAE;AAC5C,gBAAgB,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;AACjD,aAAa;AACb,SAAS;AACT,QAAQ,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;AAC9B,QAAQ,OAAO;AACf,YAAY,IAAI,EAAE,gBAAgB;AAClC,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB,YAAY,IAAI;AAChB,YAAY,MAAM;AAClB,YAAY,KAAK;AACjB,YAAY,GAAG,EAAE,OAAO,CAAC,GAAG;AAC5B,SAAS,CAAC;AACV,KAAK;AACL,CAAC;AACD,SAASmB,OAAK,CAAC,OAAO,EAAE,GAAG,EAAE;AAC7B,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AAC9B;AACA,IAAI,IAAI,CAAC,GAAG,CAAC,UAAU,IAAI,GAAG,CAAC,SAAS,KAAK,OAAO,CAAC,GAAG,CAACH,OAAK,CAAC,MAAM,CAAC,IAAI,OAAO,CAAC,GAAG,CAACA,OAAK,CAAC,gBAAgB,CAAC,EAAE;AAC/G,QAAQ,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AACpC,QAAQ,IAAI,KAAK,CAAC;AAClB,QAAQ,IAAI,IAAI,GAAG,EAAE,CAAC;AACtB,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAChB,UAAQ,CAAC,EAAE;AACxC;AACA,YAAY,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;AAC9C,YAAY,IAAI,GAAG,OAAO,CAAC,GAAG,CAACgB,OAAK,CAAC,KAAK,CAAC,GAAGW,oBAAkB,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;AAC/E,SAAS;AACT,aAAa,IAAI1B,SAAO,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,EAAE;AAC1C;AACA,YAAY,IAAI,GAAG0B,oBAAkB,CAAC,OAAO,CAAC,CAAC;AAC/C,SAAS;AACT,QAAQ,IAAI,OAAO,CAAC,GAAG,CAACX,OAAK,CAAC,iBAAiB,CAAC,EAAE;AAClD,YAAY,OAAO;AACnB,gBAAgB,IAAI,EAAE,OAAO;AAC7B,gBAAgB,KAAK,EAAE,IAAI;AAC3B,gBAAgB,KAAK;AACrB,gBAAgB,GAAG,EAAE,OAAO,CAAC,GAAG;AAChC,aAAa,CAAC;AACd,SAAS;AACT,QAAQ,MAAM,OAAO,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;AAC3C,KAAK;AACL;AACA;AACA,IAAI,OAAO,CAAC,GAAG,GAAG,KAAK,CAAC;AACxB,CAAC;AACD;AACA;AACA;AACA,SAASW,oBAAkB,CAAC,MAAM,EAAE;AACpC,IAAI,MAAM,KAAK,GAAG,EAAE,CAAC;AACrB,IAAI,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC;AAC9B,IAAI,OAAO,CAAC,MAAM,CAAC,GAAG,EAAE,EAAE;AAC1B,QAAQ,IAAI,MAAM,CAAC,GAAG,CAACX,OAAK,CAAC,gBAAgB,CAAC,EAAE;AAChD,YAAY,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AACnC,SAAS;AACT,aAAa,IAAI,MAAM,CAAC,GAAG,CAACA,OAAK,CAAC,iBAAiB,CAAC,EAAE;AACtD,YAAY,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;AAC/B,gBAAgB,MAAM,CAAC,GAAG,EAAE,CAAC;AAC7B,gBAAgB,MAAM;AACtB,aAAa;AACb,YAAY,KAAK,CAAC,GAAG,EAAE,CAAC;AACxB,SAAS;AACT,aAAa;AACb,YAAY,MAAM,CAAC,GAAG,EAAE,CAAC;AACzB,SAAS;AACT,KAAK;AACL,IAAI,IAAI,KAAK,CAAC,MAAM,EAAE;AACtB,QAAQ,MAAM,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;AACjC,QAAQ,MAAM,MAAM,CAAC,KAAK,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;AAC1C,KAAK;AACL,IAAI,OAAO,MAAM,CAAC,OAAO,EAAE,CAAC;AAC5B,CAAC;AACD;AACA;AACA;AACA,SAAS,iBAAiB,CAAC,EAAE,EAAE,GAAG,EAAE;AACpC,IAAI,MAAM,EAAE,GAAGU,cAAY,CAAC,EAAE,CAAC,CAAC;AAChC,IAAI,IAAI,CAAC,EAAE,IAAI,GAAG,CAAC,KAAK,IAAI,GAAG,CAAC,UAAU,EAAE;AAC5C;AACA,QAAQ,OAAO,KAAK,CAAC;AACrB,KAAK;AACL;AACA,IAAI,OAAO,CAAC,GAAG,CAAC,SAAS,IAAI,EAAE,KAAK,OAAO,CAAC;AAC5C,CAAC;AACD;AACA;AACA;AACA;AACA,SAAS,cAAc,CAAC,EAAE,EAAE,GAAG,EAAE;AACjC,IAAI,OAAO,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC;AAC1C,CAAC;AACD;AACA;AACA;AACA,SAAS,iBAAiB,CAAC,EAAE,EAAE,GAAG,EAAE;AACpC,IAAI,OAAO,EAAE,KAAKV,OAAK,CAAC,QAAQ,IAAI,CAAC,GAAG,CAAC,SAAS,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC;AACtE,CAAC;AACD;AACA;AACA;AACA,SAAS,WAAW,CAAC,EAAE,EAAE;AACzB,IAAI,IAAI,EAAE,KAAKA,OAAK,CAAC,gBAAgB,IAAI,EAAE,KAAKA,OAAK,CAAC,iBAAiB,EAAE;AACzE,QAAQ,OAAO,OAAO,CAAC;AACvB,KAAK;AACL,IAAI,IAAI,EAAE,KAAKA,OAAK,CAAC,iBAAiB,IAAI,EAAE,KAAKA,OAAK,CAAC,kBAAkB,EAAE;AAC3E,QAAQ,OAAO,WAAW,CAAC;AAC3B,KAAK;AACL,IAAI,IAAI,EAAE,KAAKA,OAAK,CAAC,gBAAgB,IAAI,EAAE,KAAKA,OAAK,CAAC,iBAAiB,EAAE;AACzE,QAAQ,OAAO,YAAY,CAAC;AAC5B,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA,SAASU,cAAY,CAAC,EAAE,EAAE;AAC1B,IAAI,OAAO,CAAC,EAAE,KAAKV,OAAK,CAAC,KAAK,IAAI,OAAO;AACzC,YAAY,EAAE,KAAKA,OAAK,CAAC,OAAO,IAAI,SAAS,CAAC;AAC9C,YAAY,EAAE,KAAKA,OAAK,CAAC,KAAK,IAAI,OAAO,CAAC;AAC1C,YAAY,EAAE,KAAKA,OAAK,CAAC,GAAG,IAAI,OAAO,CAAC;AACxC,YAAY,EAAE,KAAKA,OAAK,CAAC,IAAI,IAAI,IAAI,CAAC;AACtC,YAAY,EAAE,KAAKA,OAAK,CAAC,KAAK,IAAI,OAAO,CAAC;AAC1C,YAAY,EAAE,KAAKA,OAAK,CAAC,MAAM,IAAI,OAAO,CAAC;AAC3C,WAAW,KAAK,CAAC,CAAC;AAClB,CAAC;AACD;AACA;AACA;AACA,SAASS,eAAa,CAAC,EAAE,EAAE;AAC3B,IAAI,OAAO,EAAE,KAAKT,OAAK,CAAC,gBAAgB;AACxC,WAAW,EAAE,KAAKA,OAAK,CAAC,iBAAiB;AACzC,WAAW,EAAE,KAAKA,OAAK,CAAC,gBAAgB,CAAC;AACzC,CAAC;AACD;AACA;AACA;AACA,SAAS,aAAa,CAAC,EAAE,EAAE;AAC3B,IAAI,OAAO,kBAAkB,CAAC,EAAE,CAAC;AACjC,WAAW,QAAQ,CAAC,EAAE,CAAC;AACvB,WAAW,EAAE,KAAKA,OAAK,CAAC,IAAI;AAC5B,WAAW,EAAE,KAAKA,OAAK,CAAC,KAAK;AAC7B,WAAW,EAAE,KAAKA,OAAK,CAAC,IAAI,CAAC;AAC7B,CAAC;AACD;AACA,MAAM,SAAS,GAAG;AAClB,IAAI,KAAK,EAAE,GAAG;AACd,IAAI,KAAK,EAAE,GAAG;AACd,IAAI,KAAK,EAAE,GAAG;AACd,IAAI,EAAE,EAAE,GAAG;AACX,IAAI,KAAK,EAAE,GAAG;AACd,IAAI,KAAK,EAAE,GAAG;AACd,IAAI,OAAO,EAAE,GAAG;AAChB,CAAC,CAAC;AACF,MAAM,YAAY,GAAG;AACrB,IAAI,OAAO,CAAC,KAAK,EAAE;AACnB,QAAQ,OAAO,KAAK,CAAC,KAAK,CAAC;AAC3B,KAAK;AACL,IAAI,KAAK,CAAC,KAAK,EAAE;AACjB,QAAQ,OAAO,KAAK,CAAC,MAAM,GAAG,IAAI,GAAG,GAAG,CAAC;AACzC,KAAK;AACL,IAAI,OAAO,CAAC,KAAK,EAAE;AACnB,QAAQ,IAAI,KAAK,CAAC,OAAO,KAAK,WAAW,EAAE;AAC3C,YAAY,OAAO,KAAK,CAAC,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC;AAC1C,SAAS;AACT,aAAa,IAAI,KAAK,CAAC,OAAO,KAAK,YAAY,EAAE;AACjD,YAAY,OAAO,KAAK,CAAC,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC;AAC1C,SAAS;AACT,aAAa;AACb,YAAY,OAAO,KAAK,CAAC,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC;AAC1C,SAAS;AACT,KAAK;AACL,IAAI,QAAQ,CAAC,KAAK,EAAE;AACpB,QAAQ,OAAO,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;AACzC,KAAK;AACL,IAAI,KAAK,CAAC,KAAK,EAAE,KAAK,EAAE;AACxB,QAAQ,IAAI,KAAK,CAAC,KAAK,IAAI,IAAI,EAAE;AACjC;AACA,YAAY,OAAO,KAAK,CAAC,IAAI;AAC7B,kBAAkB,CAAC,GAAG,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;AACpD,kBAAkB,CAAC,GAAG,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;AACtC,SAAS;AACT,aAAa,IAAI,KAAK,CAAC,IAAI,EAAE;AAC7B;AACA,YAAY,OAAO,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AACjD,SAAS;AACT,QAAQ,OAAO,EAAE,CAAC;AAClB,KAAK;AACL,IAAI,mBAAmB,CAAC,KAAK,EAAE,KAAK,EAAE;AACtC;AACA,QAAQ,IAAI,QAAQ,CAAC;AACrB,QAAQ,KAAK,IAAI,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;AAC9D,YAAY,IAAI,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE;AAC7C,gBAAgB,QAAQ,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;AAC9C,gBAAgB,MAAM;AACtB,aAAa;AACb,SAAS;AACT,QAAQ,KAAK,CAAC,QAAQ,GAAG,IAAI,CAAC;AAC9B,QAAQ,OAAO,KAAK,CAAC,OAAO,CAAC,QAAQ,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC;AACzD,KAAK;AACL,IAAI,cAAc,CAAC,KAAK,EAAE,KAAK,EAAE;AACjC,QAAQ,IAAI,KAAK,GAAG,CAAC,CAAC;AACtB,QAAQ,MAAM,MAAM,GAAG,KAAK,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC;AAClD;AACA,QAAQ,MAAM,QAAQ,GAAG,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;AACjD,QAAQ,IAAI,QAAQ,EAAE;AACtB,YAAY,KAAK,GAAG,KAAK,CAAC,OAAO;AACjC,kBAAkB,KAAK,CAAC,IAAI,GAAG,QAAQ,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,GAAG,CAAC;AAClE,kBAAkB,KAAK,CAAC,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC;AAC9C,YAAY,IAAI,KAAK,CAAC,MAAM,EAAE;AAC9B,gBAAgB,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;AACpE,gBAAgB,IAAI,QAAQ,KAAK,MAAM,EAAE;AACzC,oBAAoB,MAAM,cAAc,GAAG,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;AACrE,oBAAoB,KAAK,IAAI,QAAQ,CAAC,KAAK,GAAG,cAAc,CAAC,KAAK,CAAC;AACnE,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,QAAQ,IAAI,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;AACnC,QAAQ,OAAO,MAAM,CAAC,MAAM,GAAG,KAAK,CAAC,IAAI,EAAE;AAC3C,YAAY,MAAM,GAAG,GAAG,GAAG,MAAM,CAAC;AAClC,SAAS;AACT,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL,IAAI,UAAU,CAAC,KAAK,EAAE;AACtB,QAAQ,OAAO,KAAK,CAAC,KAAK,CAAC;AAC3B,KAAK;AACL,CAAC,CAAC;AACF;AACA;AACA;AACA,SAASY,WAAS,CAAC,KAAK,EAAE,KAAK,EAAE;AACjC,IAAI,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AACnC,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,cAAc,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACvD,KAAK;AACL,IAAI,OAAO,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AAClD,CAAC;AACD;AACA,MAAM,QAAQ,GAAG,gDAAgD,CAAC;AAClE,MAAM,UAAU,GAAG,0CAA0C,CAAC;AAC9D;AACA;AACA;AACA;AACA,SAAS,OAAO,CAAC,IAAI,EAAE,OAAO,GAAG,EAAE,EAAE;AACrC,IAAI,IAAI,YAAY,GAAG,KAAK,CAAC;AAC7B,IAAI,IAAI,SAAS,CAAC;AAClB,IAAI,IAAI,OAAO,CAAC,IAAI,EAAE;AACtB,QAAQ,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;AACzC,YAAY,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;AAC3D,SAAS;AACT,aAAa;AACb,YAAY,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC;AACrC,SAAS;AACT,KAAK;AACL,IAAI,MAAM,MAAM,GAAG;AACnB,QAAQ,IAAI,EAAE,cAAc;AAC5B,QAAQ,QAAQ,EAAE,YAAY,CAAC,IAAI,EAAE;AACrC,YAAY,QAAQ,EAAE,KAAK;AAC3B,YAAY,SAAS,EAAE,EAAE;AACzB,YAAY,IAAI,EAAE,OAAO,CAAC,IAAI;AAC9B,YAAY,SAAS;AACrB,YAAY,WAAW,EAAE,OAAO,CAAC,SAAS,IAAI,MAAM,CAAC,iBAAiB;AACtE,YAAY,OAAO,CAAC,GAAG,EAAE;AACzB,gBAAgB,IAAI,EAAE,CAAC;AACvB,gBAAgB,YAAY,GAAG,IAAI,CAAC;AACpC,gBAAgB,IAAI,KAAK,CAAC;AAC1B,gBAAgB,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;AACjD,oBAAoB,IAAI,GAAG,KAAK,SAAS,IAAI,GAAG,IAAI,CAAC,IAAI,GAAG,GAAG,SAAS,CAAC,MAAM,EAAE;AACjF,wBAAwB,OAAO,SAAS,CAAC,GAAG,CAAC,CAAC;AAC9C,qBAAqB;AACrB,oBAAoB,KAAK,GAAG,GAAG,KAAK,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC5F,iBAAiB;AACjB,qBAAqB;AACrB,oBAAoB,KAAK,GAAG,CAAC,EAAE,GAAG,OAAO,CAAC,IAAI,MAAM,IAAI,IAAI,EAAE,KAAK,KAAK,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC;AACpF,iBAAiB;AACjB,gBAAgB,OAAO,KAAK,CAAC;AAC7B,aAAa;AACb,YAAY,WAAW,CAAC,IAAI,EAAE;AAC9B,gBAAgB,MAAM,QAAQ,GAAG,OAAO,CAAC,SAAS,IAAI,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;AAC9E,gBAAgB,OAAO,QAAQ,IAAI,IAAI,GAAG,QAAQ,GAAG,IAAI,CAAC;AAC1D,aAAa;AACb,SAAS,CAAC;AACV,KAAK,CAAC;AACN,IAAI,IAAI,OAAO,CAAC,IAAI,IAAI,IAAI,IAAI,CAAC,YAAY,EAAE;AAC/C;AACA;AACA,QAAQ,MAAM,OAAO,GAAG,WAAW,CAACC,MAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC;AAC3D,QAAQ,IAAI,OAAO,EAAE;AACrB,YAAY,MAAM,IAAI,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC;AAC9F,YAAY,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AACtC,YAAY,IAAI,OAAO,CAAC,IAAI,KAAK,GAAG,IAAI,OAAO,CAAC,IAAI,EAAE;AACtD;AACA,gBAAgB,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AAC1C,aAAa;AACb,SAAS;AACT,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD;AACA;AACA;AACA,SAAS,gBAAgB,CAAC,IAAI,EAAE,KAAK,EAAE;AACvC,IAAI,IAAI,MAAM,GAAG,EAAE,CAAC;AACpB,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE;AACrB;AACA;AACA,QAAQ,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC;AACrC,QAAQ,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;AACnD,QAAQ,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,QAAQ,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC;AACnE,cAAc,KAAK,CAAC,SAAS,CAAC,MAAM;AACpC,eAAe,MAAM,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;AAClC,QAAQ,IAAI,KAAK,CAAC;AAClB,QAAQ,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AACrC,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;AAC/C,YAAY,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC;AAC7B,YAAY,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AACjC,YAAY,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC;AACjC,kBAAkB,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC;AAC3C,kBAAkB,cAAc,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AAC9C,YAAY,IAAI,MAAM,CAAC,QAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;AACpD;AACA;AACA,gBAAgB,MAAM,MAAM,GAAGA,MAAI,CAAC,KAAK,CAAC,CAAC;AAC3C,gBAAgB,MAAM,OAAO,GAAG,MAAM,IAAI,WAAW,CAAC,MAAM,CAAC,CAAC;AAC9D,gBAAgB,IAAI,OAAO,EAAE;AAC7B,oBAAoB,UAAU,CAAC,OAAO,EAAE,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;AACrE,iBAAiB;AACjB,aAAa;AACb,YAAY,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AAC1C;AACA;AACA,YAAY,IAAI,EAAE,KAAK,CAAC,WAAW,IAAI,CAAC,EAAE;AAC1C,gBAAgB,MAAM;AACtB,aAAa;AACb,SAAS;AACT,QAAQ,KAAK,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;AAC9B,QAAQ,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC/B,QAAQ,IAAI,MAAM,CAAC,QAAQ,EAAE;AAC7B,YAAY,KAAK,CAAC,QAAQ,GAAG,IAAI,CAAC;AAClC,SAAS;AACT,KAAK;AACL,SAAS;AACT,QAAQ,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG,cAAc,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;AACxG,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD,SAAS,cAAc,CAAC,IAAI,EAAE,KAAK,EAAE;AACrC,IAAI,IAAI,QAAQ,GAAG,EAAE,CAAC;AACtB,IAAI,MAAM,IAAI,GAAG;AACjB,QAAQ,IAAI,EAAE,kBAAkB;AAChC,QAAQ,IAAI,EAAE,IAAI,CAAC,IAAI,IAAI,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC;AAC1D,QAAQ,KAAK,EAAE,IAAI,CAAC,KAAK,IAAIC,gBAAc,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC;AAC9D,QAAQ,UAAU,EAAE,KAAK,CAAC;AAC1B,QAAQ,QAAQ;AAChB,QAAQ,MAAM,EAAE,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC;AAC7D,QAAQ,WAAW,EAAE,IAAI,CAAC,SAAS;AACnC,KAAK,CAAC;AACN,IAAI,IAAI,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC;AACxB,IAAI,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;AACvC,QAAQ,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,gBAAgB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;AACnE,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,UAAU,EAAE;AACzB,QAAQ,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;AAC7B,QAAQ,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,UAAU,EAAE;AAC5C,YAAY,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;AAChE,SAAS;AACT,KAAK;AACL;AACA;AACA,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAACC,SAAO,CAAC,EAAE;AACnF;AACA;AACA,QAAQ,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AACzC,KAAK;AACL,SAAS;AACT,QAAQ,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AACjC,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD,SAAS,YAAY,CAAC,IAAI,EAAE,KAAK,EAAE;AACnC,IAAI,IAAI,MAAM,GAAG,EAAE,CAAC;AACpB,IAAI,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;AACvC,QAAQ,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;AAC/D,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE;AACrB,QAAQ,MAAM,GAAG,cAAc,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;AACrD,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD,SAAS,gBAAgB,CAAC,IAAI,EAAE,KAAK,EAAE;AACvC,IAAI,IAAI,OAAO,GAAG,KAAK,CAAC;AACxB,IAAI,IAAI,SAAS,GAAG,KAAK,CAAC;AAC1B,IAAI,IAAI,SAAS,GAAG,IAAI,CAAC,UAAU,GAAG,YAAY,GAAG,KAAK,CAAC;AAC3D,IAAI,IAAI,KAAK,CAAC;AACd,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AAC9D,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AACjC,QAAQ,OAAO,GAAG,IAAI,CAAC;AACvB,KAAK;AACL,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;AAC/C,QAAQ,SAAS,GAAG,IAAI,CAAC;AACzB,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,KAAK,EAAE;AACpB,QAAQ,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;AAC1C,QAAQ,IAAI5B,SAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;AAChC;AACA;AACA,YAAY,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;AACzC,YAAY,IAAI,MAAM,CAAC,MAAM,IAAI0B,MAAI,CAAC,MAAM,CAAC,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,EAAE;AACnE,gBAAgB,MAAM,CAAC,GAAG,EAAE,CAAC;AAC7B,aAAa;AACb,YAAY,SAAS,GAAG,KAAK,CAAC,MAAM,GAAG,aAAa,GAAG,aAAa,CAAC;AACrE,SAAS;AACT,aAAa,IAAIlB,WAAS,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,YAAY,EAAE,IAAI,CAAC,EAAE;AAC3D;AACA,YAAY,SAAS,GAAG,YAAY,CAAC;AACrC,YAAY,MAAM,CAAC,KAAK,EAAE,CAAC;AAC3B,YAAY,IAAIA,WAAS,CAACkB,MAAI,CAAC,MAAM,CAAC,EAAE,YAAY,EAAE,KAAK,CAAC,EAAE;AAC9D,gBAAgB,MAAM,CAAC,GAAG,EAAE,CAAC;AAC7B,aAAa;AACb,SAAS;AACT,QAAQ,KAAK,GAAGC,gBAAc,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;AAC9C,KAAK;AACL,IAAI,OAAO;AACX,QAAQ,IAAI,EAAE,SAAS,IAAI,OAAO;AAClC,cAAc,IAAI,CAAC,KAAK,CAAC,OAAO,GAAG,CAAC,GAAG,CAAC,EAAE,SAAS,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC;AAClE,cAAc,IAAI;AAClB,QAAQ,KAAK;AACb,QAAQ,OAAO,EAAE,SAAS;AAC1B,QAAQ,OAAO;AACf,QAAQ,SAAS;AACjB,QAAQ,QAAQ,EAAE,IAAI,CAAC,QAAQ;AAC/B,KAAK,CAAC;AACN,CAAC;AACD;AACA;AACA;AACA,SAAS,aAAa,CAAC,MAAM,EAAE,KAAK,EAAE;AACtC,IAAI,IAAI,GAAG,GAAG,EAAE,CAAC;AACjB,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC5C,QAAQ,GAAG,IAAIF,WAAS,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;AAC3C,KAAK;AACL,IAAI,OAAO,GAAG,CAAC;AACf,CAAC;AACD;AACA;AACA;AACA,SAASE,gBAAc,CAAC,MAAM,EAAE,KAAK,EAAE;AACvC,IAAI,MAAM,MAAM,GAAG,EAAE,CAAC;AACtB,IAAI,IAAI,GAAG,GAAG,EAAE,CAAC;AACjB,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,KAAK,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACnD,QAAQ,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AAC1B,QAAQ,IAAIC,SAAO,CAAC,KAAK,CAAC,EAAE;AAC5B;AACA;AACA;AACA,YAAY,IAAI,GAAG,EAAE;AACrB,gBAAgB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACjC,gBAAgB,GAAG,GAAG,EAAE,CAAC;AACzB,aAAa;AACb,YAAY,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC/B,SAAS;AACT,aAAa;AACb,YAAY,GAAG,IAAIH,WAAS,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AAC3C,SAAS;AACT,KAAK;AACL,IAAI,IAAI,GAAG,EAAE;AACb,QAAQ,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACzB,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD,SAAS,OAAO,CAAC,IAAI,EAAE;AACvB,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,YAAY,CAAC;AACtC,CAAC;AACD,SAASG,SAAO,CAAC,KAAK,EAAE;AACxB,IAAI,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,CAAC,IAAI,KAAK,OAAO,IAAI,KAAK,CAAC,KAAK,IAAI,IAAI,CAAC;AACtF,CAAC;AACD,SAASF,MAAI,CAAC,GAAG,EAAE;AACnB,IAAI,OAAO,GAAG,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC/B,CAAC;AACD,SAAS,WAAW,CAAC,IAAI,EAAE;AAC3B,IAAI,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,WAAW,CAACA,MAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC;AAC1E,CAAC;AACD,SAAS,UAAU,CAAC,IAAI,EAAE,IAAI,EAAE;AAChC,IAAI,IAAI,IAAI,CAAC,KAAK,EAAE;AACpB,QAAQ,MAAM,SAAS,GAAGA,MAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC3C,QAAQ,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;AAC3C,YAAY,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC;AACtD,SAAS;AACT,aAAa;AACb,YAAY,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAClC,SAAS;AACT,KAAK;AACL,SAAS;AACT,QAAQ,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC;AAC5B,KAAK;AACL,CAAC;AACD,SAAS,UAAU,CAAC,IAAI,EAAE,IAAI,EAAE;AAChC,IAAI,IAAI,EAAE,CAAC;AACX,IAAI,IAAI,IAAI,GAAG,EAAE,CAAC;AAClB,IAAI,IAAI,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;AAC7B,QAAQ,IAAI,GAAG,IAAI,CAAC;AACpB,QAAQ,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;AAC1D,YAAY,IAAI,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC;AACpC,SAAS;AACT,KAAK;AACL,SAAS,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;AACpC,QAAQ,IAAI,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC;AAChC,KAAK;AACL,IAAI,MAAM,aAAa,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,UAAU,MAAM,IAAI,IAAI,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC;AAC5H,IAAI,IAAI,CAAC,aAAa,EAAE;AACxB,QAAQ,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;AAC9B,YAAY,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;AACjC,SAAS;AACT,QAAQ,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,IAAI,CAAC,EAAE,SAAS,EAAE,aAAa,EAAE,CAAC,CAAC;AACxF,KAAK;AACL,SAAS,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE;AACnC,QAAQ,aAAa,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC;AACrC,KAAK;AACL,CAAC;AACD,SAAS,cAAc,CAAC,KAAK,EAAE,QAAQ,EAAE;AACzC,IAAI,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;AAC9B,QAAQ,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;AAC1B,YAAY,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;AACtD,SAAS;AACT,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC;AACD;AACA;AACA;AACA;AACA,SAAS,iBAAiB,CAAC,IAAI,EAAE,OAAO,EAAE;AAC1C,IAAI,IAAI;AACR,QAAQ,MAAM,MAAM,GAAG,OAAO,IAAI,KAAK,QAAQ,GAAGZ,UAAQ,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;AACxE,QAAQ,OAAO,OAAO,CAAC,YAAY,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE,OAAO,CAAC,CAAC;AAC/D,KAAK;AACL,IAAI,OAAO,GAAG,EAAE;AAChB,QAAQ,IAAI,GAAG,YAAY,YAAY,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;AACrE,YAAY,GAAG,CAAC,OAAO,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AAChE,SAAS;AACT,QAAQ,MAAM,GAAG,CAAC;AAClB,KAAK;AACL;;AC/sCA,IAAI,YAAY,CAAC;AACjB,CAAC,UAAU,YAAY,EAAE;AACzB,IAAI,YAAY,CAAC,SAAS,CAAC,GAAG,GAAG,CAAC;AAClC,IAAI,YAAY,CAAC,WAAW,CAAC,GAAG,GAAG,CAAC;AACpC,IAAI,YAAY,CAAC,mBAAmB,CAAC,GAAG,GAAG,CAAC;AAC5C,IAAI,YAAY,CAAC,gBAAgB,CAAC,GAAG,GAAG,CAAC;AACzC,IAAI,YAAY,CAAC,mBAAmB,CAAC,GAAG,GAAG,CAAC;AAC5C,CAAC,EAAE,YAAY,KAAK,YAAY,GAAG,EAAE,CAAC,CAAC,CAAC;AACxC;AACA,IAAID,OAAK,CAAC;AACV,CAAC,UAAU,KAAK,EAAE;AAClB;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,MAAM,CAAC;AACvC;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,GAAG,QAAQ,CAAC;AAC3C;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,MAAM,CAAC;AACvC;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,GAAG,KAAK,CAAC;AACrC;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,GAAG,OAAO,CAAC;AACzC;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,GAAG,OAAO,CAAC;AACzC;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,MAAM,CAAC;AACvC;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC;AACnC;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS,CAAC;AAC7C;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,GAAG,YAAY,CAAC;AACnD;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,kBAAkB,CAAC,GAAG,EAAE,CAAC,GAAG,kBAAkB,CAAC;AAC/D;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,mBAAmB,CAAC,GAAG,EAAE,CAAC,GAAG,mBAAmB,CAAC;AACjE;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,kBAAkB,CAAC,GAAG,GAAG,CAAC,GAAG,kBAAkB,CAAC;AAChE;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,mBAAmB,CAAC,GAAG,GAAG,CAAC,GAAG,mBAAmB,CAAC;AAClE;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS,CAAC;AAC7C;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,GAAG,aAAa,CAAC;AACrD;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,GAAG,aAAa,CAAC;AACrD;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,aAAa,CAAC,GAAG,GAAG,CAAC,GAAG,aAAa,CAAC;AACtD;AACA,IAAI,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,GAAG,OAAO,CAAC;AACzC,CAAC,EAAEA,OAAK,KAAKA,OAAK,GAAG,EAAE,CAAC,CAAC,CAAC;AAC1B;AACA,SAAS,QAAQ,CAAC,IAAI,EAAE,OAAO,EAAE;AACjC,IAAI,IAAI,QAAQ,GAAG,CAAC,CAAC;AACrB,IAAI,IAAI,KAAK,CAAC;AACd,IAAI,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,IAAI,CAAC,CAAC;AACtC,IAAI,MAAM,MAAM,GAAG,EAAE,CAAC;AACtB,IAAI,OAAO,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE;AAC3B,QAAQ,KAAK,GAAG,QAAQ,CAAC,OAAO,EAAE,QAAQ,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AAC9D,QAAQ,IAAI,CAAC,KAAK,EAAE;AACpB,YAAY,MAAM,OAAO,CAAC,KAAK,CAAC,sBAAsB,CAAC,CAAC;AACxD,SAAS;AACT,QAAQ,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE;AACtC,YAAY,IAAI,CAAC,QAAQ,IAAI,KAAK,CAAC,IAAI,EAAE;AACzC,gBAAgB,WAAW,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;AAC7C,aAAa;AACb,YAAY,QAAQ,IAAI,KAAK,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAC5C,YAAY,IAAI,QAAQ,GAAG,CAAC,EAAE;AAC9B,gBAAgB,MAAM,OAAO,CAAC,KAAK,CAAC,oBAAoB,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;AACvE,aAAa;AACb,SAAS;AACT,QAAQ,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC3B;AACA;AACA,QAAQ,IAAI,sBAAsB,CAAC,KAAK,CAAC,KAAK,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC,EAAE;AAC1E,YAAY,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC/B,SAAS;AACT,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD;AACA;AACA;AACA,SAAS,QAAQ,CAAC,OAAO,EAAE,KAAK,EAAE;AAClC,IAAI,OAAOG,OAAK,CAAC,OAAO,CAAC;AACzB,WAAW,cAAc,CAAC,OAAO,CAAC;AAClC,WAAW,WAAW,CAAC,OAAO,CAAC;AAC/B,WAAW,UAAU,CAAC,OAAO,CAAC;AAC9B,WAAW,WAAW,CAAC,OAAO,CAAC;AAC/B,WAAW,OAAO,CAAC,OAAO,CAAC;AAC3B,WAAW,QAAQ,CAAC,OAAO,CAAC;AAC5B,WAAW,UAAU,CAAC,OAAO,CAAC;AAC9B,WAAWE,SAAO,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AACnC,CAAC;AACD,SAASF,OAAK,CAAC,OAAO,EAAE;AACxB,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AAC9B,IAAI,IAAI,OAAO,CAAC,GAAG,CAACH,OAAK,CAAC,MAAM,CAAC,IAAI,OAAO,CAAC,GAAG,CAACA,OAAK,CAAC,gBAAgB,CAAC,EAAE;AAC1E,QAAQ,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AACpC,QAAQ,IAAI,KAAK,CAAC;AAClB,QAAQ,IAAI,IAAI,GAAG,EAAE,CAAC;AACtB,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAChB,UAAQ,CAAC,EAAE;AACxC;AACA,YAAY,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;AAC9C,YAAY,IAAI,GAAG,OAAO,CAAC,GAAG,CAACgB,OAAK,CAAC,KAAK,CAAC,GAAGW,oBAAkB,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;AAC/E,SAAS;AACT,aAAa,IAAI1B,SAAO,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,EAAE;AAC1C;AACA,YAAY,IAAI,GAAG0B,oBAAkB,CAAC,OAAO,CAAC,CAAC;AAC/C,SAAS;AACT,QAAQ,IAAI,OAAO,CAAC,GAAG,CAACX,OAAK,CAAC,iBAAiB,CAAC,EAAE;AAClD,YAAY,OAAO;AACnB,gBAAgB,IAAI,EAAE,OAAO;AAC7B,gBAAgB,KAAK,EAAE,IAAI;AAC3B,gBAAgB,KAAK;AACrB,gBAAgB,GAAG,EAAE,OAAO,CAAC,GAAG;AAChC,aAAa,CAAC;AACd,SAAS;AACT,QAAQ,MAAM,OAAO,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;AAC3C,KAAK;AACL;AACA;AACA,IAAI,OAAO,CAAC,GAAG,GAAG,KAAK,CAAC;AACxB,CAAC;AACD;AACA;AACA;AACA,SAASW,oBAAkB,CAAC,MAAM,EAAE;AACpC,IAAI,MAAM,KAAK,GAAG,EAAE,CAAC;AACrB,IAAI,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC;AAC9B,IAAI,OAAO,CAAC,MAAM,CAAC,GAAG,EAAE,EAAE;AAC1B,QAAQ,IAAI,MAAM,CAAC,GAAG,CAACX,OAAK,CAAC,gBAAgB,CAAC,EAAE;AAChD,YAAY,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AACnC,SAAS;AACT,aAAa,IAAI,MAAM,CAAC,GAAG,CAACA,OAAK,CAAC,iBAAiB,CAAC,EAAE;AACtD,YAAY,IAAI,CAAC