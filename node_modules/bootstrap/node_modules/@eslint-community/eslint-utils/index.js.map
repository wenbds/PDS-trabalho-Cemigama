{"version":3,"file":"index.js","sources":["src/get-innermost-scope.mjs","src/find-variable.mjs","src/token-predicate.mjs","src/get-function-head-location.mjs","src/get-static-value.mjs","src/get-string-if-constant.mjs","src/get-property-name.mjs","src/get-function-name-with-kind.mjs","src/has-side-effect.mjs","src/is-parenthesized.mjs","src/pattern-matcher.mjs","src/reference-tracker.mjs","src/index.mjs"],"sourcesContent":["/** @typedef {import(\"eslint\").Scope.Scope} Scope */\n/** @typedef {import(\"estree\").Node} Node */\n\n/**\n * Get the innermost scope which contains a given location.\n * @param {Scope} initialScope The initial scope to search.\n * @param {Node} node The location to search.\n * @returns {Scope} The innermost scope.\n */\nexport function getInnermostScope(initialScope, node) {\n    const location = /** @type {[number, number]} */ (node.range)[0]\n\n    let scope = initialScope\n    let found = false\n    do {\n        found = false\n        for (const childScope of scope.childScopes) {\n            const range = /** @type {[number, number]} */ (\n                childScope.block.range\n            )\n\n            if (range[0] <= location && location < range[1]) {\n                scope = childScope\n                found = true\n                break\n            }\n        }\n    } while (found)\n\n    return scope\n}\n","import { getInnermostScope } from \"./get-innermost-scope.mjs\"\n/** @typedef {import(\"eslint\").Scope.Scope} Scope */\n/** @typedef {import(\"eslint\").Scope.Variable} Variable */\n/** @typedef {import(\"estree\").Identifier} Identifier */\n\n/**\n * Find the variable of a given name.\n * @param {Scope} initialScope The scope to start finding.\n * @param {string|Identifier} nameOrNode The variable name to find. If this is a Node object then it should be an Identifier node.\n * @returns {Variable|null} The found variable or null.\n */\nexport function findVariable(initialScope, nameOrNode) {\n    let name = \"\"\n    /** @type {Scope|null} */\n    let scope = initialScope\n\n    if (typeof nameOrNode === \"string\") {\n        name = nameOrNode\n    } else {\n        name = nameOrNode.name\n        scope = getInnermostScope(scope, nameOrNode)\n    }\n\n    while (scope != null) {\n        const variable = scope.set.get(name)\n        if (variable != null) {\n            return variable\n        }\n        scope = scope.upper\n    }\n\n    return null\n}\n","/** @typedef {import(\"eslint\").AST.Token} Token */\n/** @typedef {import(\"estree\").Comment} Comment */\n/** @typedef {import(\"./types.mjs\").ArrowToken} ArrowToken */\n/** @typedef {import(\"./types.mjs\").CommaToken} CommaToken */\n/** @typedef {import(\"./types.mjs\").SemicolonToken} SemicolonToken */\n/** @typedef {import(\"./types.mjs\").ColonToken} ColonToken */\n/** @typedef {import(\"./types.mjs\").OpeningParenToken} OpeningParenToken */\n/** @typedef {import(\"./types.mjs\").ClosingParenToken} ClosingParenToken */\n/** @typedef {import(\"./types.mjs\").OpeningBracketToken} OpeningBracketToken */\n/** @typedef {import(\"./types.mjs\").ClosingBracketToken} ClosingBracketToken */\n/** @typedef {import(\"./types.mjs\").OpeningBraceToken} OpeningBraceToken */\n/** @typedef {import(\"./types.mjs\").ClosingBraceToken} ClosingBraceToken */\n/**\n * @template {string} Value\n * @typedef {import(\"./types.mjs\").PunctuatorToken<Value>} PunctuatorToken\n */\n\n/** @typedef {Comment | Token} CommentOrToken */\n\n/**\n * Creates the negate function of the given function.\n * @param {function(CommentOrToken):boolean} f - The function to negate.\n * @returns {function(CommentOrToken):boolean} Negated function.\n */\nfunction negate(f) {\n    return (token) => !f(token)\n}\n\n/**\n * Checks if the given token is a PunctuatorToken with the given value\n * @template {string} Value\n * @param {CommentOrToken} token - The token to check.\n * @param {Value} value - The value to check.\n * @returns {token is PunctuatorToken<Value>} `true` if the token is a PunctuatorToken with the given value.\n */\nfunction isPunctuatorTokenWithValue(token, value) {\n    return token.type === \"Punctuator\" && token.value === value\n}\n\n/**\n * Checks if the given token is an arrow token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is ArrowToken} `true` if the token is an arrow token.\n */\nexport function isArrowToken(token) {\n    return isPunctuatorTokenWithValue(token, \"=>\")\n}\n\n/**\n * Checks if the given token is a comma token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is CommaToken} `true` if the token is a comma token.\n */\nexport function isCommaToken(token) {\n    return isPunctuatorTokenWithValue(token, \",\")\n}\n\n/**\n * Checks if the given token is a semicolon token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is SemicolonToken} `true` if the token is a semicolon token.\n */\nexport function isSemicolonToken(token) {\n    return isPunctuatorTokenWithValue(token, \";\")\n}\n\n/**\n * Checks if the given token is a colon token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is ColonToken} `true` if the token is a colon token.\n */\nexport function isColonToken(token) {\n    return isPunctuatorTokenWithValue(token, \":\")\n}\n\n/**\n * Checks if the given token is an opening parenthesis token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is OpeningParenToken} `true` if the token is an opening parenthesis token.\n */\nexport function isOpeningParenToken(token) {\n    return isPunctuatorTokenWithValue(token, \"(\")\n}\n\n/**\n * Checks if the given token is a closing parenthesis token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is ClosingParenToken} `true` if the token is a closing parenthesis token.\n */\nexport function isClosingParenToken(token) {\n    return isPunctuatorTokenWithValue(token, \")\")\n}\n\n/**\n * Checks if the given token is an opening square bracket token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is OpeningBracketToken} `true` if the token is an opening square bracket token.\n */\nexport function isOpeningBracketToken(token) {\n    return isPunctuatorTokenWithValue(token, \"[\")\n}\n\n/**\n * Checks if the given token is a closing square bracket token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is ClosingBracketToken} `true` if the token is a closing square bracket token.\n */\nexport function isClosingBracketToken(token) {\n    return isPunctuatorTokenWithValue(token, \"]\")\n}\n\n/**\n * Checks if the given token is an opening brace token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is OpeningBraceToken} `true` if the token is an opening brace token.\n */\nexport function isOpeningBraceToken(token) {\n    return isPunctuatorTokenWithValue(token, \"{\")\n}\n\n/**\n * Checks if the given token is a closing brace token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is ClosingBraceToken} `true` if the token is a closing brace token.\n */\nexport function isClosingBraceToken(token) {\n    return isPunctuatorTokenWithValue(token, \"}\")\n}\n\n/**\n * Checks if the given token is a comment token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is Comment} `true` if the token is a comment token.\n */\nexport function isCommentToken(token) {\n    return [\"Block\", \"Line\", \"Shebang\"].includes(token.type)\n}\n\nexport const isNotArrowToken = negate(isArrowToken)\nexport const isNotCommaToken = negate(isCommaToken)\nexport const isNotSemicolonToken = negate(isSemicolonToken)\nexport const isNotColonToken = negate(isColonToken)\nexport const isNotOpeningParenToken = negate(isOpeningParenToken)\nexport const isNotClosingParenToken = negate(isClosingParenToken)\nexport const isNotOpeningBracketToken = negate(isOpeningBracketToken)\nexport const isNotClosingBracketToken = negate(isClosingBracketToken)\nexport const isNotOpeningBraceToken = negate(isOpeningBraceToken)\nexport const isNotClosingBraceToken = negate(isClosingBraceToken)\nexport const isNotCommentToken = negate(isCommentToken)\n","import { isArrowToken, isOpeningParenToken } from \"./token-predicate.mjs\"\n/** @typedef {import(\"eslint\").Rule.Node} RuleNode */\n/** @typedef {import(\"eslint\").SourceCode} SourceCode */\n/** @typedef {import(\"eslint\").AST.Token} Token */\n/** @typedef {import(\"estree\").Function} FunctionNode */\n/** @typedef {import(\"estree\").FunctionDeclaration} FunctionDeclaration */\n/** @typedef {import(\"estree\").FunctionExpression} FunctionExpression */\n/** @typedef {import(\"estree\").SourceLocation} SourceLocation */\n/** @typedef {import(\"estree\").Position} Position */\n\n/**\n * Get the `(` token of the given function node.\n * @param {FunctionExpression | FunctionDeclaration} node - The function node to get.\n * @param {SourceCode} sourceCode - The source code object to get tokens.\n * @returns {Token} `(` token.\n */\nfunction getOpeningParenOfParams(node, sourceCode) {\n    return node.id\n        ? /** @type {Token} */ (\n              sourceCode.getTokenAfter(node.id, isOpeningParenToken)\n          )\n        : /** @type {Token} */ (\n              sourceCode.getFirstToken(node, isOpeningParenToken)\n          )\n}\n\n/**\n * Get the location of the given function node for reporting.\n * @param {FunctionNode} node - The function node to get.\n * @param {SourceCode} sourceCode - The source code object to get tokens.\n * @returns {SourceLocation|null} The location of the function node for reporting.\n */\nexport function getFunctionHeadLocation(node, sourceCode) {\n    const parent = /** @type {RuleNode} */ (node).parent\n\n    /** @type {Position|null} */\n    let start = null\n    /** @type {Position|null} */\n    let end = null\n\n    if (node.type === \"ArrowFunctionExpression\") {\n        const arrowToken = /** @type {Token} */ (\n            sourceCode.getTokenBefore(node.body, isArrowToken)\n        )\n\n        start = arrowToken.loc.start\n        end = arrowToken.loc.end\n    } else if (\n        parent.type === \"Property\" ||\n        parent.type === \"MethodDefinition\" ||\n        parent.type === \"PropertyDefinition\"\n    ) {\n        start = /** @type {SourceLocation} */ (parent.loc).start\n        end = getOpeningParenOfParams(node, sourceCode).loc.start\n    } else {\n        start = /** @type {SourceLocation} */ (node.loc).start\n        end = getOpeningParenOfParams(node, sourceCode).loc.start\n    }\n\n    return {\n        start: { ...start },\n        end: { ...end },\n    }\n}\n","/* globals globalThis, global, self, window */\n\nimport { findVariable } from \"./find-variable.mjs\"\n/** @typedef {import(\"./types.mjs\").StaticValue} StaticValue */\n/** @typedef {import(\"eslint\").Scope.Scope} Scope */\n/** @typedef {import(\"eslint\").Scope.Variable} Variable */\n/** @typedef {import(\"estree\").Node} Node */\n/** @typedef {import(\"@typescript-eslint/types\").TSESTree.Node} TSESTreeNode */\n/** @typedef {import(\"@typescript-eslint/types\").TSESTree.AST_NODE_TYPES} TSESTreeNodeTypes */\n/** @typedef {import(\"@typescript-eslint/types\").TSESTree.MemberExpression} MemberExpression */\n/** @typedef {import(\"@typescript-eslint/types\").TSESTree.Property} Property */\n/** @typedef {import(\"@typescript-eslint/types\").TSESTree.RegExpLiteral} RegExpLiteral */\n/** @typedef {import(\"@typescript-eslint/types\").TSESTree.BigIntLiteral} BigIntLiteral */\n/** @typedef {import(\"@typescript-eslint/types\").TSESTree.Literal} Literal */\n\nconst globalObject =\n    typeof globalThis !== \"undefined\"\n        ? globalThis\n        : // @ts-ignore\n        typeof self !== \"undefined\"\n        ? // @ts-ignore\n          self\n        : // @ts-ignore\n        typeof window !== \"undefined\"\n        ? // @ts-ignore\n          window\n        : typeof global !== \"undefined\"\n        ? global\n        : {}\n\nconst builtinNames = Object.freeze(\n    new Set([\n        \"Array\",\n        \"ArrayBuffer\",\n        \"BigInt\",\n        \"BigInt64Array\",\n        \"BigUint64Array\",\n        \"Boolean\",\n        \"DataView\",\n        \"Date\",\n        \"decodeURI\",\n        \"decodeURIComponent\",\n        \"encodeURI\",\n        \"encodeURIComponent\",\n        \"escape\",\n        \"Float32Array\",\n        \"Float64Array\",\n        \"Function\",\n        \"Infinity\",\n        \"Int16Array\",\n        \"Int32Array\",\n        \"Int8Array\",\n        \"isFinite\",\n        \"isNaN\",\n        \"isPrototypeOf\",\n        \"JSON\",\n        \"Map\",\n        \"Math\",\n        \"NaN\",\n        \"Number\",\n        \"Object\",\n        \"parseFloat\",\n        \"parseInt\",\n        \"Promise\",\n        \"Proxy\",\n        \"Reflect\",\n        \"RegExp\",\n        \"Set\",\n        \"String\",\n        \"Symbol\",\n        \"Uint16Array\",\n        \"Uint32Array\",\n        \"Uint8Array\",\n        \"Uint8ClampedArray\",\n        \"undefined\",\n        \"unescape\",\n        \"WeakMap\",\n        \"WeakSet\",\n    ]),\n)\nconst callAllowed = new Set(\n    [\n        Array.isArray,\n        Array.of,\n        Array.prototype.at,\n        Array.prototype.concat,\n        Array.prototype.entries,\n        Array.prototype.every,\n        Array.prototype.filter,\n        Array.prototype.find,\n        Array.prototype.findIndex,\n        Array.prototype.flat,\n        Array.prototype.includes,\n        Array.prototype.indexOf,\n        Array.prototype.join,\n        Array.prototype.keys,\n        Array.prototype.lastIndexOf,\n        Array.prototype.slice,\n        Array.prototype.some,\n        Array.prototype.toString,\n        Array.prototype.values,\n        typeof BigInt === \"function\" ? BigInt : undefined,\n        Boolean,\n        Date,\n        Date.parse,\n        decodeURI,\n        decodeURIComponent,\n        encodeURI,\n        encodeURIComponent,\n        escape,\n        isFinite,\n        isNaN,\n        // @ts-ignore\n        isPrototypeOf,\n        Map,\n        Map.prototype.entries,\n        Map.prototype.get,\n        Map.prototype.has,\n        Map.prototype.keys,\n        Map.prototype.values,\n        .../** @type {(keyof typeof Math)[]} */ (\n            Object.getOwnPropertyNames(Math)\n        )\n            .filter((k) => k !== \"random\")\n            .map((k) => Math[k])\n            .filter((f) => typeof f === \"function\"),\n        Number,\n        Number.isFinite,\n        Number.isNaN,\n        Number.parseFloat,\n        Number.parseInt,\n        Number.prototype.toExponential,\n        Number.prototype.toFixed,\n        Number.prototype.toPrecision,\n        Number.prototype.toString,\n        Object,\n        Object.entries,\n        Object.is,\n        Object.isExtensible,\n        Object.isFrozen,\n        Object.isSealed,\n        Object.keys,\n        Object.values,\n        parseFloat,\n        parseInt,\n        RegExp,\n        Set,\n        Set.prototype.entries,\n        Set.prototype.has,\n        Set.prototype.keys,\n        Set.prototype.values,\n        String,\n        String.fromCharCode,\n        String.fromCodePoint,\n        String.raw,\n        String.prototype.at,\n        String.prototype.charAt,\n        String.prototype.charCodeAt,\n        String.prototype.codePointAt,\n        String.prototype.concat,\n        String.prototype.endsWith,\n        String.prototype.includes,\n        String.prototype.indexOf,\n        String.prototype.lastIndexOf,\n        String.prototype.normalize,\n        String.prototype.padEnd,\n        String.prototype.padStart,\n        String.prototype.slice,\n        String.prototype.startsWith,\n        String.prototype.substr,\n        String.prototype.substring,\n        String.prototype.toLowerCase,\n        String.prototype.toString,\n        String.prototype.toUpperCase,\n        String.prototype.trim,\n        String.prototype.trimEnd,\n        String.prototype.trimLeft,\n        String.prototype.trimRight,\n        String.prototype.trimStart,\n        Symbol.for,\n        Symbol.keyFor,\n        unescape,\n    ].filter((f) => typeof f === \"function\"),\n)\nconst callPassThrough = new Set([\n    Object.freeze,\n    Object.preventExtensions,\n    Object.seal,\n])\n\n/** @type {ReadonlyArray<readonly [Function, ReadonlySet<string>]>} */\nconst getterAllowed = [\n    [Map, new Set([\"size\"])],\n    [\n        RegExp,\n        new Set([\n            \"dotAll\",\n            \"flags\",\n            \"global\",\n            \"hasIndices\",\n            \"ignoreCase\",\n            \"multiline\",\n            \"source\",\n            \"sticky\",\n            \"unicode\",\n        ]),\n    ],\n    [Set, new Set([\"size\"])],\n]\n\n/**\n * Get the property descriptor.\n * @param {object} object The object to get.\n * @param {string|number|symbol} name The property name to get.\n */\nfunction getPropertyDescriptor(object, name) {\n    let x = object\n    while ((typeof x === \"object\" || typeof x === \"function\") && x !== null) {\n        const d = Object.getOwnPropertyDescriptor(x, name)\n        if (d) {\n            return d\n        }\n        x = Object.getPrototypeOf(x)\n    }\n    return null\n}\n\n/**\n * Check if a property is getter or not.\n * @param {object} object The object to check.\n * @param {string|number|symbol} name The property name to check.\n */\nfunction isGetter(object, name) {\n    const d = getPropertyDescriptor(object, name)\n    return d != null && d.get != null\n}\n\n/**\n * Get the element values of a given node list.\n * @param {(Node|TSESTreeNode|null)[]} nodeList The node list to get values.\n * @param {Scope|undefined|null} initialScope The initial scope to find variables.\n * @returns {any[]|null} The value list if all nodes are constant. Otherwise, null.\n */\nfunction getElementValues(nodeList, initialScope) {\n    const valueList = []\n\n    for (let i = 0; i < nodeList.length; ++i) {\n        const elementNode = nodeList[i]\n\n        if (elementNode == null) {\n            valueList.length = i + 1\n        } else if (elementNode.type === \"SpreadElement\") {\n            const argument = getStaticValueR(elementNode.argument, initialScope)\n            if (argument == null) {\n                return null\n            }\n            valueList.push(.../** @type {Iterable<any>} */ (argument.value))\n        } else {\n            const element = getStaticValueR(elementNode, initialScope)\n            if (element == null) {\n                return null\n            }\n            valueList.push(element.value)\n        }\n    }\n\n    return valueList\n}\n\n/**\n * Checks if a variable is a built-in global.\n * @param {Variable|null} variable The variable to check.\n * @returns {variable is Variable & {defs:[]}}\n */\nfunction isBuiltinGlobal(variable) {\n    return (\n        variable != null &&\n        variable.defs.length === 0 &&\n        builtinNames.has(variable.name) &&\n        variable.name in globalObject\n    )\n}\n\n/**\n * Checks if a variable can be considered as a constant.\n * @param {Variable} variable\n * @returns {variable is Variable & {defs: [import(\"eslint\").Scope.Definition & { type: \"Variable\" }]}} True if the variable can be considered as a constant.\n */\nfunction canBeConsideredConst(variable) {\n    if (variable.defs.length !== 1) {\n        return false\n    }\n    const def = variable.defs[0]\n    return Boolean(\n        def.parent &&\n            def.type === \"Variable\" &&\n            (def.parent.kind === \"const\" || isEffectivelyConst(variable)),\n    )\n}\n\n/**\n * Returns whether the given variable is never written to after initialization.\n * @param {Variable} variable\n * @returns {boolean}\n */\nfunction isEffectivelyConst(variable) {\n    const refs = variable.references\n\n    const inits = refs.filter((r) => r.init).length\n    const reads = refs.filter((r) => r.isReadOnly()).length\n    if (inits === 1 && reads + inits === refs.length) {\n        // there is only one init and all other references only read\n        return true\n    }\n    return false\n}\n\n/**\n * Checks if a variable has mutation in its property.\n * @param {Variable} variable The variable to check.\n * @param {Scope|null} initialScope The scope to start finding variable. Optional. If the node is a computed property node and this scope was given, this checks the computed property name by the `getStringIfConstant` function with the scope, and returns the value of it.\n * @returns {boolean} True if the variable has mutation in its property.\n */\nfunction hasMutationInProperty(variable, initialScope) {\n    for (const ref of variable.references) {\n        let node = /** @type {TSESTreeNode} */ (ref.identifier)\n        while (node && node.parent && node.parent.type === \"MemberExpression\") {\n            node = node.parent\n        }\n        if (!node || !node.parent) {\n            continue\n        }\n        if (\n            (node.parent.type === \"AssignmentExpression\" &&\n                node.parent.left === node) ||\n            (node.parent.type === \"UpdateExpression\" &&\n                node.parent.argument === node)\n        ) {\n            // This is a mutation.\n            return true\n        }\n        if (\n            node.parent.type === \"CallExpression\" &&\n            node.parent.callee === node &&\n            node.type === \"MemberExpression\"\n        ) {\n            const methodName = getStaticPropertyNameValue(node, initialScope)\n            if (isNameOfMutationArrayMethod(methodName)) {\n                // This is a mutation.\n                return true\n            }\n        }\n    }\n    return false\n\n    /**\n     * Checks if a method name is one of the mutation array methods.\n     * @param {StaticValue|null} methodName The method name to check.\n     * @returns {boolean} True if the method name is a mutation array method.\n     */\n    function isNameOfMutationArrayMethod(methodName) {\n        if (methodName == null || methodName.value == null) {\n            return false\n        }\n        const name = methodName.value\n        return (\n            name === \"copyWithin\" ||\n            name === \"fill\" ||\n            name === \"pop\" ||\n            name === \"push\" ||\n            name === \"reverse\" ||\n            name === \"shift\" ||\n            name === \"sort\" ||\n            name === \"splice\" ||\n            name === \"unshift\"\n        )\n    }\n}\n\n/**\n * @template {TSESTreeNodeTypes} T\n * @callback VisitorCallback\n * @param {TSESTreeNode & { type: T }} node\n * @param {Scope|undefined|null} initialScope\n * @returns {StaticValue | null}\n */\n/**\n * @typedef { { [K in TSESTreeNodeTypes]?: VisitorCallback<K> } } Operations\n */\n/**\n * @type {Operations}\n */\nconst operations = Object.freeze({\n    ArrayExpression(node, initialScope) {\n        const elements = getElementValues(node.elements, initialScope)\n        return elements != null ? { value: elements } : null\n    },\n\n    AssignmentExpression(node, initialScope) {\n        if (node.operator === \"=\") {\n            return getStaticValueR(node.right, initialScope)\n        }\n        return null\n    },\n\n    //eslint-disable-next-line complexity\n    BinaryExpression(node, initialScope) {\n        if (node.operator === \"in\" || node.operator === \"instanceof\") {\n            // Not supported.\n            return null\n        }\n\n        const left = getStaticValueR(node.left, initialScope)\n        const right = getStaticValueR(node.right, initialScope)\n        if (left != null && right != null) {\n            switch (node.operator) {\n                case \"==\":\n                    return { value: left.value == right.value } //eslint-disable-line eqeqeq\n                case \"!=\":\n                    return { value: left.value != right.value } //eslint-disable-line eqeqeq\n                case \"===\":\n                    return { value: left.value === right.value }\n                case \"!==\":\n                    return { value: left.value !== right.value }\n                case \"<\":\n                    return {\n                        value:\n                            /** @type {any} */ (left.value) <\n                            /** @type {any} */ (right.value),\n                    }\n                case \"<=\":\n                    return {\n                        value:\n                            /** @type {any} */ (left.value) <=\n                            /** @type {any} */ (right.value),\n                    }\n                case \">\":\n                    return {\n                        value:\n                            /** @type {any} */ (left.value) >\n                            /** @type {any} */ (right.value),\n                    }\n                case \">=\":\n                    return {\n                        value:\n                            /** @type {any} */ (left.value) >=\n                            /** @type {any} */ (right.value),\n                    }\n                case \"<<\":\n                    return {\n                        value:\n                            /** @type {any} */ (left.value) <<\n                            /** @type {any} */ (right.value),\n                    }\n                case \">>\":\n                    return {\n                        value:\n                            /** @type {any} */ (left.value) >>\n                            /** @type {any} */ (right.value),\n                    }\n                case \">>>\":\n                    return {\n                        value:\n                            /** @type {any} */ (left.value) >>>\n                            /** @type {any} */ (right.value),\n                    }\n                case \"+\":\n                    return {\n                        value:\n                            /** @type {any} */ (left.value) +\n                            /** @type {any} */ (right.value),\n                    }\n                case \"-\":\n                    return {\n                        value:\n                            /** @type {any} */ (left.value) -\n                            /** @type {any} */ (right.value),\n                    }\n                case \"*\":\n                    return {\n                        value:\n                            /** @type {any} */ (left.value) *\n                            /** @type {any} */ (right.value),\n                    }\n                case \"/\":\n                    return {\n                        value:\n                            /** @type {any} */ (left.value) /\n                            /** @type {any} */ (right.value),\n                    }\n                case \"%\":\n                    return {\n                        value:\n                            /** @type {any} */ (left.value) %\n                            /** @type {any} */ (right.value),\n                    }\n                case \"**\":\n                    return {\n                        value:\n                            /** @type {any} */ (left.value) **\n                            /** @type {any} */ (right.value),\n                    }\n                case \"|\":\n                    return {\n                        value:\n                            /** @type {any} */ (left.value) |\n                            /** @type {any} */ (right.value),\n                    }\n                case \"^\":\n                    return {\n                        value:\n                            /** @type {any} */ (left.value) ^\n                            /** @type {any} */ (right.value),\n                    }\n                case \"&\":\n                    return {\n                        value:\n                            /** @type {any} */ (left.value) &\n                            /** @type {any} */ (right.value),\n                    }\n\n                // no default\n            }\n        }\n\n        return null\n    },\n\n    CallExpression(node, initialScope) {\n        const calleeNode = node.callee\n        const args = getElementValues(node.arguments, initialScope)\n\n        if (args != null) {\n            if (calleeNode.type === \"MemberExpression\") {\n                if (calleeNode.property.type === \"PrivateIdentifier\") {\n                    return null\n                }\n                const object = getStaticValueR(calleeNode.object, initialScope)\n                if (object != null) {\n                    if (\n                        object.value == null &&\n                        (object.optional || node.optional)\n                    ) {\n                        return { value: undefined, optional: true }\n                    }\n                    const property = getStaticPropertyNameValue(\n                        calleeNode,\n                        initialScope,\n                    )\n\n                    if (property != null) {\n                        const receiver =\n                       